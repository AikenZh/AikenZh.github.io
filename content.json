{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/03/06/hello-world/"},{"title":"算法基础","text":"时间复杂度、空间复杂度内容：略 选择排序描述：略 代码： 1 冒泡排序描述：略 代码： 1 插入排序描述：略 代码： 1 二分查找123456789101112131415161718192021222324252627282930def binary_search_recursion(ilist: list, inum: int) -&gt; bool: if not ilist: return False if len(ilist) == 1: return ilist.pop() == inum m = len(ilist) &gt;&gt; 2 if inum == ilist[m]: return True elif inum &gt; ilist[m]: return binary_search_recursion(ilist[m+1:], inum) else: return binary_search_recursion(ilist[:m], inum)def binary_search(ilist: list, inum: int) -&gt; bool: if not ilist: return False if len(ilist) == 1: return ilist.pop() == inum l = 0 r = len(ilist) - 1 while l &lt; r: m = l + ((r-l) &gt;&gt; 2) if inum == ilist[m]: return True elif inum &gt; ilist[m]: l = m + 1 else: r = m - 1 return inum == ilist[l] 应用： 有序数组中找到&gt;=num 最左的位置 1 有序数组中找到&lt;=num 最右的位置 ​ 1 局部最小值问题定义何为局部最小值：arr[0] &lt; arr[1]，0 位置是局部最小；arr[N-1] &lt; arr[N-2]，N-1 位置是局部最小；arr[i-1] &gt; arr[i] &lt; arr[i+1]，i 位置是局部最小；给定一个数组 arr，已知任何两个相邻的数都不相等，找到随便一个局部最小位置返回 1 异或运算内容： 异或运算满足交换律与结合律，即a ^ b = b ^ a，a ^ b ^ c = a ^ (b ^ c) 题目： 不用额外变量交换两个数的值 12345a = 10b = 20a = a ^ b # 此时 a = 10 ^ 20b = a ^ b # 相当于 (10 ^ 20) ^ 20 = 10a = a ^ b # 相当于 (10 ^ 20) ^ 10 = 20 不用额外变量交换数组中两个数的值 一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数 怎么把一个 int 类型的数，提取出二进制中最右侧的 1 来 一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数 一个数组中有一种数出现 K 次，其他数都出现了 M 次，已知 M &gt; 1，K &lt; M，找到出现了 K 次的数要求额外空间复杂度 O(1)，时间复杂度 O(N) 03 单双链表、栈和队列、递归和 Master 公式、哈希表和有序表的使用和性能内容： 单链表、双链表 栈、队列 递归的物理实质 评估递归复杂度的 Master 公式 哈希表的使用和性能 有序表的使用和性能 题目： 反转单链表、反转双链表 在链表中删除指定值的所有节点 用双链表实现栈和队列 用环形数组实现栈和队列 实现有 getMin 功能的栈 两个栈实现队列 两个队列实现栈 用递归行为得到数组中的最大值，并用 master 公式来估计时间复杂度 哈希表和有序表使用的 code 展示 04 归并排序及其常见面试题内容： 归并排序 题目： 归并排序的递归和非递归实现 在一个数组中，一个数左边比它小的数的总和，叫该数的小和所有数的小和累加起来，叫数组小和例子： [1,3,4,2,5]1 左边比 1 小的数：没有3 左边比 3 小的数：14 左边比 4 小的数：1、32 左边比 2 小的数：15 左边比 5 小的数：1、3、4、 2所以数组的小和为 1+1+3+1+1+3+4+2=16给定一个数组 arr，求数组小和 在一个数组中，任何一个前面的数 a，和任何一个后面的数 b，如果(a,b)是降序的，就称为降序对给定一个数组 arr，求数组的降序对总数量 在一个数组中，对于任何一个数 num，求有多少个(后面的数*2)依然&lt;num，返回总个数比如：[3,1,7,0,2]3 的后面有：1，01 的后面有：07 的后面有：0，20 的后面没有2 的后面没有所以总共有 5 个 05 归并排序面试题(续)、快速排序内容： 再来一个归并排序面试题 荷兰国旗问题 快速排序 1.0 快速排序 2.0 快速排序 3.0 题目： 给定一个数组 arr，两个整数 lower 和 upper，返回 arr 中有多少个子数组的累加和在[lower,upper]范围上Leetcode 题目：https://leetcode.com/problems/count-of-range-sum/ 荷兰国旗问题的实现 快速排序从 1.0 到 3.0 的实现 快速排序的递归实现和非递归实现 code 附加，双向链表进行快速排序的 code 实现 06 比较器、堆结构、堆排序内容： 比较器 堆结构 堆排序 建立大根堆的两种方式，从上到下、从下到上，及其复杂度分析 题目： 比较器使用的 code 展示 堆结构的实现 堆排序的实现 b 已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过 kk 相对于数组长度来说是比较小的。请选择一个合适的排序策略，对这个数组进行排序。 07 和堆有关的面试题、加强堆结构内容： 线段最大重合问题 加强堆的实现 题目： 给定很多线段，每个线段都有两个数[start, end]，表示线段开始位置和结束位置，左右都是闭区间规定：1）线段的开始和结束位置一定都是整数值2）线段重合区域的长度必须&gt;=1返回线段最多重合区域中，包含了几条线段 加强堆的实现、注意点解析 做一个加强堆的题目，给定一个整型数组，int[] arr；和一个布尔类型数组，boolean[] op两个数组一定等长，假设长度为 N，arr[i]表示客户编号，op[i]表示客户操作arr= [3,3,1,2,1,2,5…op = [T,T,T,T,F,T,F…依次表示：3 用户购买了一件商品3 用户购买了一件商品1 用户购买了一件商品2 用户购买了一件商品1 用户退货了一件商品2 用户购买了一件商品5 用户退货了一件商品…一对 arr[i]和 op[i]就代表一个事件：用户号为 arr[i]，op[i] == T 就代表这个用户购买了一件商品op[i] == F 就代表这个用户退货了一件商品现在你作为电商平台负责人，你想在每一个事件到来的时候，都给购买次数最多的前 K 名用户颁奖。所以每个事件发生后，你都需要一个得奖名单（得奖区）。得奖系统的规则：1，如果某个用户购买商品数为 0，但是又发生了退货事件， 则认为该事件无效，得奖名单和上一个事件发生后一致，例子中的 5 用户2，某用户发生购买商品事件，购买商品数+1，发生退货事件，购买商品数-13，每次都是最多 K 个用户得奖，K 也为传入的参数 如果根据全部规则，得奖人数确实不够 K 个，那就以不够的情况输出结果4，得奖系统分为得奖区和候选区，任何用户只要购买数&gt;0， 一定在这两个区域中的一个5，购买数最大的前 K 名用户进入得奖区， 在最初时如果得奖区没有到达 K 个用户，那么新来的用户直接进入得奖区6，如果购买数不足以进入得奖区的用户，进入候选区7，如果候选区购买数最多的用户，已经足以进入得奖区， 该用户就会替换得奖区中购买数最少的用户（大于才能替换）， 如果得奖区中购买数最少的用户有多个，就替换最早进入得奖区的用户 如果候选区中购买数最多的用户有多个，机会会给最早进入候选区的用户8，候选区和得奖区是两套时间， 因用户只会在其中一个区域，所以只会有一个区域的时间，另一个没有 从得奖区出来进入候选区的用户，得奖区时间删除， 进入候选区的时间就是当前事件的时间（可以理解为 arr[i]和 op[i]中的 i） 从候选区出来进入得奖区的用户，候选区时间删除， 进入得奖区的时间就是当前事件的时间（可以理解为 arr[i]和 op[i]中的 i）9，如果某用户购买数==0，不管在哪个区域都离开，区域时间删除， 离开是指彻底离开，哪个区域也不会找到该用户 如果下次该用户又发生购买行为，产生&gt;0 的购买数， 会再次根据之前规则回到某个区域中，进入区域的时间重记请遍历 arr 数组和 op 数组，遍历每一步输出一个得奖名单public List&lt;List&gt; topK (int[] arr, boolean[] op, int k) 08 前缀树、不基于比较的排序（计数排序、基数排序）、排序算法的稳定性内容： 前缀树 计数排序 基数排序 排序算法的稳定性 题目： 前缀树实现 计数排序 基数排序 09 排序算法大总结、链表及其相关面试题内容： 排序算法总结 排序算法常见的坑 工程上对排序的常见改进 链表面试题的常见技巧 题目： 输入链表头节点，奇数长度返回中点，偶数长度返回上中点输入链表头节点，奇数长度返回中点，偶数长度返回下中点输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个 给定一个单链表的头节点 head，请判断该链表是否为回文结构 给定一个单链表的头节点 head，给定一个整数 n，将链表按 n 划分成左边&lt;n、中间==n、右边&gt;n 一种特殊的单链表节点类描述如下class Node {int value;Node next;Node rand;Node(int val) { value = val; }}rand 指针是单链表节点结构中新增的指针，rand 可能指向链表中的任意一个节点，也可能指向 null给定一个由 Node 节点类型组成的无环单链表的头节点 head，请实现一个函数完成这个链表的复制返回复制的新链表的头节点，要求时间复杂度 O(N)，额外空间复杂度 O(1) 10 链表相关面试题（续）、二叉树的常见遍历内容： 单链表的相交节点系列问题 一种看似高效其实搞笑的节点删除方式 二叉树的中序、先序、后序遍历 题目： 给定两个可能有环也可能无环的单链表，头节点 head1 和 head2请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交返回 null要求如果两个链表长度之和为 N，时间复杂度请达到 O(N)，额外空间复杂度请达到 O(1) 能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？ 二叉树先序、中序、后序的递归遍历和递归序 二叉树先序、中序、后序的非递归遍历 11 二叉树常见面试题和二叉树的递归套路（上）内容： 通过题目来熟悉二叉树的解题技巧 题目： 二叉树的按层遍历 二叉树的序列化和反序列化 N 叉树如何通过二叉树来序列化、并完成反序列化Leetcode 题目：https://leetcode.com/problems/encode-n-ary-tree-to-binary-tree/ 打印二叉树的函数设计 求二叉树的最大宽度 求二叉树某个节点的后继节点二叉树结构如下定义：Class Node { V value; Node left; Node right; Node parent;}给你二叉树中的某个节点，返回该节点的后继节点 折纸问题请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折 1 次，压出折痕后展开此时折痕是凹下去的，即折痕突起的方向指向纸条的背面如果从纸条的下边向上方连续对折 2 次，压出折痕后展开此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。给定一个输入参数 N，代表纸条都从下边向上方连续对折 N 次请从上到下打印所有折痕的方向。N=1 时，打印: downN=2 时，打印: down down up 12 二叉树常见面试题和二叉树的递归套路（中）内容： 通过题目来熟悉二叉树的解题技巧 介绍二叉树的递归套路1）假设以 X 节点为头，假设可以向 X 左树和 X 右树要任何信息2）在上一步的假设下，讨论以 X 为头节点的树，得到答案的可能性（最重要）3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息4）把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息 S5）递归函数都返回 S，每一棵子树都这么要求6）写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息 题目： 判断二叉树是不是搜索二叉树 判断二叉树是不是平衡二叉树 判断二叉树是不是满二叉树 给定一棵二叉树的头节点 head，返回这颗二叉树中最大的二叉搜索子树的大小 给定一棵二叉树的头节点 head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离 13 二叉树常见面试题和二叉树的递归套路（下）、贪心算法内容： 二叉树递归套路继续实践 一道贪心算法从头到尾的完整做法 解决贪心题目的重要技巧，即对数器来验证脑洞 再次强调对数器的重要性 题目： 判断二叉树是不是完全二叉树（一般方法解决、递归套路解决） 给定一棵二叉树的头节点 head，返回这颗二叉树中最大的二叉搜索子树的头节点 给定一棵二叉树的头节点 head，和另外两个节点 a 和 b，返回 a 和 b 的最低公共祖先 派对的最大快乐值 员工信息的定义如下:class Employee { public int happy; // 这名员工可以带来的快乐值 List subordinates; // 这名员工有哪些直接下级}公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树树的头节点是公司唯一的老板，除老板之外的每个员工都有唯一的直接上级叶节点是没有任何下属的基层员工(subordinates 列表为空)，除基层员工外每个员工都有一个或多个直接下级这个公司现在要办 party，你可以决定哪些员工来，哪些员工不来，规则：1.如果某个员工来了，那么这个员工的所有直接下级都不能来2.派对的整体快乐值是所有到场员工快乐值的累加3.你的目标是让派对的整体快乐值尽量大给定一棵多叉树的头节点 boss，请返回派对的最大快乐值。 给定一个由字符串组成的数组 strs，必须把所有的字符串拼接起来，返回所有可能的拼接结果中字典序最小的结果 14 贪心算法（续）、并查集内容： 贪心算法继续实战 并查集详解 题目： 给定一个字符串 str，只由’X’和’.’两种字符构成‘X’表示墙，不能放灯，也不需要点亮；’.’表示居民点，可以放灯，需要点亮如果灯放在 i 位置，可以让 i-1，i 和 i+1 三个位置被点亮返回如果点亮 str 中所有需要点亮的位置，至少需要几盏灯 一块金条切成两半，是需要花费和长度数值一样的铜板比如长度为 20 的金条，不管怎么切都要花费 20 个铜板，一群人想整分整块金条，怎么分最省铜板?例如，给定数组{10,20,30}，代表一共三个人，整块金条长度为 60，金条要分成 10，20，30 三个部分。如果先把长度 60 的金条分成 10 和 50，花费 60；再把长度 50 的金条分成 20 和 30，花费 50；一共花费 110 铜板但如果先把长度 60 的金条分成 30 和 30，花费 60；再把长度 30 金条分成 10 和 20，花费 30；一共花费 90 铜板 输入一个数组，返回分割的最小代价 一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲，给你每一个项目开始的时间和结束的时间你来安排宣讲的日程，要求会议室进行的宣讲的场次最多，返回最多的宣讲场次 输入正数数组 costs、正数数组 profits、正数 K 和正数 M costs[i]表示 i 号项目的花费profits[i]表示 i 号项目在扣除花费之后还能挣到的钱(利润)K 表示你只能串行的最多做 k 个项目M 表示你初始的资金说明：每做完一个项目，马上获得的收益，可以支持你去做下一个项目，不能并行的做项目。输出：最后获得的最大钱数 并查集的实现 15 并查集相关的常见面试题内容： 通过解答实际出现的面试题来体会并查集的优势、熟悉并查集的使用 题目： 一群朋友中，有几个不相交的朋友圈Leetcode 题目：https://leetcode.com/problems/friend-circles/ 岛问题（递归解法 + 并查集解法 + 并行解法）给定一个二维数组 matrix，里面的值不是 1 就是 0，上、下、左、右相邻的 1 认为是一片岛，返回 matrix 中岛的数量 16 图及其与图相关的算法内容： 图的表达方式 图的常见描述 图的宽度优先遍历 图的深度优先遍历 图的拓扑排序 最小生成树算法 Kruskal 最小生成树算法 Prim 单元最短路径算法 Dijkstra 题目： 图的数据结构抽象 实现图的宽度优先遍历 实现图的深度优先遍历 三种方式实现图的拓扑排序 用并查集实现 Kruskal 算法 用堆实现 Prim 算法 实现 Dijkstra 算法，用加强堆做更好的实现（16 节+17 节一开始） 17 用加强堆更好的实现 Dijkstra 算法、常见的递归内容： 加强堆实现 Dijkstra 算法 递归的设计 常见的递归 题目： 打印 n 层汉诺塔从最左边移动到最右边的全部过程（递归+非递归实现） 12345678910111213141516171819202122232425def recursion(n: int, src: str, dst: str, other: str): if n == 1: print(f&quot;move {n} from {src} to {dst}&quot;) else: recursion(n-1, src, other, dst) print(f&quot;move {n} from {src} to {dst}&quot;) recursion(n-1, other, dst, src)def non_recursion(n: int, src: str, dst: str, other: str): stack = [] stack.append([n, src, dst, other, False]) while stack: r = stack.pop() if r[0] == 1: print(f&quot;move {r[0]} from {r[1]} to {r[2]}&quot;) if stack: # 由于1一定是在最顶上的，如果此时栈非空，则只代表原本1下面的元素可以移动 stack[-1][4] = True else: if not r[4]: # 该元素当前是否可以移动，即元素上方是否有其他元素 stack.append(r) stack.append([r[0]-1, r[1], r[3], r[2], False]) else: print(f&quot;move {r[0]} from {r[1]} to {r[2]}&quot;) stack.append([r[0]-1, r[3], r[2], r[1], False]) 打印一个字符串的全部子序列（可重复+不可重复） 1234567891011121314def process1(istr: str, idx: int, prefix: str, res: list): if idx == len(istr): res.append(prefix) return process1(istr, idx+1, prefix, res) process1(istr, idx+1, prefix+istr[idx], res)def process2(istr: str, idx: int, prefix: str, res: set): if idx == len(istr): res.add(prefix) return process2(istr, idx+1, prefix, res) process2(istr, idx+1, prefix+istr[idx], res) 打印一个字符串的全部排列（可重复+不可重复） 123456789101112131415161718def process1(prefix: str, istr: str, res: list): if not istr: res.append(prefix) return for _ in range(len(istr)): s, istr = istr[0], istr[1:] process1(prefix+s, istr, res) istr += sdef process2(prefix: str, istr: str, res: set): if not istr: res.add(prefix) return for _ in range(len(istr)): s, istr = istr[0], istr[1:] process2(prefix+s, istr, res) istr += s 给定一个栈，请逆序这个栈，不能申请额外的数据结构，只能使用递归函数 123456789101112131415def get_head(stack: list): if len(stack) == 1: return stack.pop() temp = stack.pop() head = get_head(stack) stack.append(temp) return headdef process(stack: list): if len(stack) == 1: return head = get_head(stack) process(stack) stack.append(head) 18 暴力递归到动态规划（一）内容： 讲述暴力递归和动态规划的关系 记忆化搜索 动态规划都可以由暴力递归改进过来，解决动态规划的套路 常见的尝试模型 设计尝试过程的原则 本节是暴力递归到动态规划的总纲（很重要） 后续的课都是在讲述这一系列的套路 题目： 假设有排成一行的 N 个位置记为 1…N，N 一定大于或等于 2，开始时机器人在其中的 M 位置上(M 一定是 1…N 中的一个)如果机器人来到 1 位置，那么下一步只能往右来到 2 位置；如果机器人来到 N 位置，那么下一步只能往左来到 N-1 位置；如果机器人来到中间位置，那么下一步可以往左走或者往右走；规定机器人必须走 K 步，最终能来到 P 位置(P 也是 1~N 中的一个)的方法有多少种给定四个参数 N、M、K、P，返回方法数 1234567891011121314151617181920def recursion(border, cur, step, dst): if step == 0: return 0 if cur != dst else 1 ways = 0 if cur &gt; 1: # 左 ways += recursion(border, cur-1, step-1, dst) if cur &lt; border: # 右 ways += recursion(border, cur+1, step-1, dst) return waysdef dp(border, cur, step, dst): dp = [[0 for _ in range(step+1)] for _ in range(border+1)] dp[dst][0] = 1 for rest in range(1, step+1): dp[1][rest] = dp[2][rest-1] dp[border][rest] = dp[border-1][rest-1] for pos in range(2, border): dp[pos][rest] = dp[pos-1][rest-1] + dp[pos+1][rest-1] return dp[cur][step] 给定一个整型数组 arr，代表数值不同的纸牌排成一条线玩家 A 和玩家 B 依次拿走每张纸牌规定玩家 A 先拿，玩家 B 后拿但是每个玩家每次只能拿走最左或最右的纸牌玩家 A 和玩家 B 都绝顶聪明请返回最后获胜者的分数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162def first(cards: list) -&gt; int: if len(cards) == 1: return cards[0] # 先手拿左的得分+剩下的牌中我后手的得分 p1 = cards[0] + second(cards[1:]) # 先手拿右的得分+剩下的牌中我后手的得分 p2 = cards[-1] + second(cards[:-1]) # 取最大值 return max(p1, p2)def second(cards: list) -&gt; int: if len(cards) == 1: return 0 # 对面拿走左之后，我在剩下的牌中先手的得分 p1 = first(cards[1:]) # 对面拿走右之后，我在剩下的牌中先手的得分 p2 = first(cards[:-1]) # 取最小值，因为对面会让我在剩下的牌中得分少 return min(p1, p2)def recursion(cards: list) -&gt; int: return max(first(cards), second(cards))def first1(cards: list, l, r) -&gt; int: if l == r: return cards[l] # 先手拿左的得分+剩下的牌中我后手的得分 p1 = cards[l] + second1(cards, l+1, r) # 先手拿右的得分+剩下的牌中我后手的得分 p2 = cards[r] + second1(cards, l, r-1) # 取最大值 return max(p1, p2)def second1(cards: list, l, r) -&gt; int: if l == r: return 0 # 对面拿走左之后，我在剩下的牌中先手的得分 p1 = first1(cards, l+1, r) # 对面拿走右之后，我在剩下的牌中先手的得分 p2 = first1(cards, l, r-1) # 取最小值，因为对面会让我在剩下的牌中得分少 return min(p1, p2)def dp(cards: list) -&gt; int: n = len(cards) dp_f = [[0 for _ in range(n)] for _ in range(n)] dp_s = [[0 for _ in range(n)] for _ in range(n)] for l in range(n-1, -1, -1): for r in range(l, n): if l == r: dp_f[l][r] = cards[l] else: dp_f[l][r] = max(cards[l] + dp_s[l+1][r], cards[r] + dp_s[l][r-1]) dp_s[l][r] = min(dp_f[l+1][r], dp_f[l][r-1]) return max(dp_f[0][r], dp_s[0][r]) 19 暴力递归到动态规划（二）内容： 以 18 节为总纲 背包问题 记忆化搜索的一个很重要的注意点 通过面试题进一步强化动态规划的解题套路 题目： 背包问题给定两个长度都为 N 的数组 weights 和 values，weights[i]和 values[i]分别代表 i 号物品的重量和价值给定一个正数 bag，表示一个载重 bag 的袋子，装的物品不能超过这个重量返回能装下的最大价值 123456789101112131415161718192021222324252627def process(weights: list, values: list, idx: int, bag: int) -&gt; int: if idx == len(weights): return 0 p1 = process(weights, values, idx+1, bag) if bag - weights[idx] &gt;= 0: p2 = values[idx] + process(weights, values, idx+1, bag-weights[idx]) return max(p1, p2) return p1def recursion(weights: list, values: list, bag: int) -&gt; int: return process(weights, values, 0, bag)def dp(weights: list, values: list, bag: int) -&gt; int: n = len(weights) record = [[0 for _ in range(bag+1)] for _ in range(n+1)] # idx == n -&gt; 0 for idx in range(n-1, -1, -1): for rest in range(bag+1): p1 = record[idx+1][rest] if rest - weights[idx] &gt;= 0: p2 = values[idx] + record[idx+1][rest - weights[idx]] record[idx][rest] = max(p1, p2) else: record[idx][rest] = p1 return record[0][bag] 规定 1 和 A 对应、2 和 B 对应、3 和 C 对应…26 和 Z 对应那么一个数字字符串比如”111”就可以转化为:“AAA”、”KA”和”AK”给定一个只有数字字符组成的字符串 str，返回有多少种转化结果 1234567891011121314151617181920212223242526272829def process(istr: str, idx: int) -&gt; int: if idx == len(istr): return 1 if istr[idx] == '0': return 0 # 要一个 ways = process(istr, idx+1) # 要两个 if idx+1 &lt; len(istr) and int(istr[idx:idx+2]) &lt; 27: return ways + process(istr, idx+2) return waysdef recursion(istr: str) -&gt; int: return process(istr, 0)def dp(istr: str) -&gt; int: record = [0 for _ in range(len(istr)+1)] record[-1] = 1 for idx in range(len(istr)-1, -1, -1): if istr[idx] == '0': continue ways = record[idx+1] if idx+1 &lt; len(istr) and int(istr[idx:idx+2]) &lt; 27: record[idx] = ways + record[idx+2] else: record[idx] = ways return record[0] 给定一个字符串 str，给定一个字符串类型的数组 arr，出现的字符都是小写英文arr 每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出 str 来返回需要至少多少张贴纸可以完成这个任务例子：str= “babac”，arr = {“ba”,”c”,”abcd”}ba + ba + c 3 abcd + abcd 2 abcd+ba 2所以返回 2 1234567891011121314151617181920212223242526272829303132def process(istr: str, sticker_counts: list, record: dict) -&gt; int: if istr in record.keys(): return record[istr] if not istr: return 0 istr_counts = [0 for _ in range(26)] for s in istr: istr_counts[ord(s) - ord('a')] += 1 # 遍历看用哪张贴纸可以去掉最多的字符 res = 0xffff for sticker in sticker_counts: # 优先考虑确认有效的贴纸(剪枝) if sticker[ord(istr[0]) - ord('a')] == 0: continue rest = &quot;&quot; for i in range(26): if istr_counts[i] &gt; 0: rest_num = istr_counts[i] - sticker[i] rest += chr(ord('a') + i) * rest_num res = min(res, process(rest, sticker_counts, record)) record[istr] = res + 1 return res + 1def recursion(istr: str, stickers: list) -&gt; int: sticker_counts = [[0 for _ in range(26)] for _ in range(len(stickers))] for idx, sticker in enumerate(stickers): for s in sticker: sticker_counts[idx][ord(s) - ord('a')] += 1 record = {} res = process(istr, sticker_counts, record) return -1 if res &gt;= 0xffff else res 给定两个字符串 str1 和 str2，返回这两个字符串的最长公共子序列长度比如 ： str1 = “a12b3c456d”,str2 = “1ef23ghi4j56k”最长公共子序列是“123456”，所以返回长度 6 12345678910111213141516171819202122232425262728def process(str1: str, str2: str, i: int, j: int) -&gt; int: if i &lt; 0 or j &lt; 0: return 0 p1 = process(str1, str2, i-1, j) p2 = process(str1, str2, i, j-1) p3 = 0 if str1[i] == str2[j]: p3 = process(str1, str2, i-1, j-1) + 1 return max(p1, p2, p3)def dp(str1: str, str2: str) -&gt; int: record = [[0 for _ in range(len(str2))] for _ in range(len(str1))] record[0][0] = 1 if str1[0] == str2[0] else 0 for i in range(1, len(str1)): record[i][0] = max(record[i-1][0], 1 if str1[i] == str2[0] else 0) for j in range(1, len(str2)): record[0][j] = max(record[0][j-1], 1 if str1[0] == str2[j] else 0) for i in range(1, len(str1)): for j in range(1, len(str2)): p1 = record[i-1][j] p2 = record[i][j-1] p3 = 0 if str1[i] == str2[j]: p3 = record[i-1][j-1] + 1 record[i][j] = max(p1, p2, p3) return record[-1][-1] 20 暴力递归到动态规划（三）内容： 以 18 节为总纲 通过面试题进一步强化动态规划的解题套路 题目： 给定一个字符串 str，返回这个字符串的最长回文子序列长度比如 ： str = “a12b3c43def2ghi1kpm”最长回文子序列是“1234321”或者“123c321”，返回长度 7 12345678910111213141516171819202122232425262728293031323334353637def process(istr: str, l: int, r: int) -&gt; int: if l == r: return 1 if r - l == 1: return 2 if istr[l] == istr[r] else 1 p1 = process(istr, l+1, r) p2 = process(istr, l, r-1) p3 = 0 if istr[l] == istr[r]: p3 = process(istr, l+1, r-1) + 2 return max(p1, p2, p3)def recursion(istr: str) -&gt; int: return process(istr, 0, len(istr) - 1)def dp(istr: str) -&gt; int: n = len(istr) record = [[0 for _ in range(n)] for _ in range(n)] # for i in range(n): # record[i][i] = 1 # for l in range(n-1): # record[l][l+1] = 2 if istr[l] == istr[l+1] else 1 # 将两个循环合并 record[-1][-1] = 1 for i in range(n-1): record[i][i] = 1 record[i][i+1] = 2 if istr[i] == istr[i+1] else 1 for l in range(n-3, -1, -1): for r in range(l+2, n): record[l][r] = max(record[l+1][r], record[l][r-1]) if istr[l] == istr[r]: record[l][r] = max(record[l][r], record[l+1][r-1] + 2) return record[0][n-1] 请同学们自行搜索或者想象一个象棋的棋盘，然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置那么整个棋盘就是横坐标上 9 条线、纵坐标上 10 条线的区域给你三个 参数 x，y，k返回“马”从(0,0)位置出发，必须走 k 步最后落在(x,y)上的方法数有多少种? 123456789101112131415161718192021222324252627282930313233343536373839404142434445def process(src: tuple, dst: tuple, step: int) -&gt; int: if (not 0 &lt;= src[0] &lt;= 8) or (not 0 &lt;= src[1] &lt;= 9): return 0 if step == 0: return 1 if src == dst else 0 # 八个方向 res = 0 res += process((src[0]+1, src[1]+2), dst, step-1) res += process((src[0]+1, src[1]-2), dst, step-1) res += process((src[0]+2, src[1]+1), dst, step-1) res += process((src[0]+2, src[1]-1), dst, step-1) res += process((src[0]-1, src[1]+2), dst, step-1) res += process((src[0]-1, src[1]-2), dst, step-1) res += process((src[0]-2, src[1]+1), dst, step-1) res += process((src[0]-2, src[1]-1), dst, step-1) return resdef recursion(dst: tuple, step: int) -&gt; int: return process((0, 0), dst, step)def dp(dst: tuple, step: int) -&gt; int: record = [[[0 for _ in range(10)] for _ in range(9)] for _ in range(step+1)] record[0][dst[0]][dst[1]] = 1 def get_valid_value(pos: tuple, k: int): if (not 0 &lt;= pos[0] &lt;= 8) or (not 0 &lt;= pos[1] &lt;= 9): return 0 return record[k][pos[0]][pos[1]] for k in range(1, step+1): for x in range(9): for y in range(10): res = 0 res += get_valid_value((x+1, y+2), k-1) res += get_valid_value((x+1, y-2), k-1) res += get_valid_value((x+2, y+1), k-1) res += get_valid_value((x+2, y-1), k-1) res += get_valid_value((x-1, y+2), k-1) res += get_valid_value((x-1, y-2), k-1) res += get_valid_value((x-2, y+1), k-1) res += get_valid_value((x-2, y-1), k-1) record[k][x][y] = res return record[step][0][0] 给定一个数组 arr，arr[i]代表第 i 号咖啡机泡一杯咖啡的时间给定一个正数 N，表示 N 个人等着咖啡机泡咖啡，每台咖啡机只能轮流泡咖啡只有一台咖啡机，一次只能洗一个杯子，时间耗费 a，洗完才能洗下一杯每个咖啡杯也可以自己挥发干净，时间耗费 b，咖啡杯可以并行挥发假设所有人拿到咖啡之后立刻喝干净，返回从开始等到所有咖啡机变干净的最短时间三个参数：int[] arr、int N，int a、int b 21 暴力递归到动态规划（四）内容： 以 18 节为总纲 通过面试题进一步强化动态规划的解题套路 题目： 给定一个二维数组 matrix，一个人必须从左上角出发，最后到达右下角沿途只可以向下或者向右走，沿途的数字都累加就是距离累加和返回最小距离累加和 12345678910111213def dp(matrix: list) -&gt; int: lenx = len(matrix) leny = len(matrix[0]) record = [[0 for _ in range(leny)] for _ in range(lenx)] record[0][0] = matrix[0][0] for i in range(1, lenx): record[i][0] = record[i-1][0] + matrix[i][0] for i in range(1, leny): record[0][i] = record[0][i-1] + matrix[0][i] for x in range(1, lenx): for y in range(1, leny): record[x][y] = min(record[x][y-1], record[x-1][y]) + matrix[x][y] return record[lenx-1][leny-1] arr 是货币数组，其中的值都是正数。再给定一个正数 aim。每个值都认为是一张货币，即便是值相同的货币也认为每一张都是不同的，返回组成 aim 的方法数例如：arr = {1,1,1}，aim = 2第 0 个和第 1 个能组成 2，第 1 个和第 2 个能组成 2，第 0 个和第 2 个能组成 2一共就 3 种方法，所以返回 3 123456789101112131415161718192021def process(arr: list, idx: int, rest: int) -&gt; int: if rest &lt; 0: return 0 if idx == len(arr): return 1 if rest == 0 else 0 return process(arr, idx+1, rest) + process(arr, idx+1, rest-arr[idx])def recursion(arr: list, aim: int) -&gt; int: return process(arr, 0, aim)def dp(arr: list, aim: int) -&gt; int: record = [[0 for _ in range(aim+1)] for _ in range(len(arr)+1)] record[-1][0] = 1 for idx in range(len(arr)-1, -1, -1): for rest in range(aim+1): record[idx][rest] = record[idx+1][rest] if rest-arr[idx] &gt;= 0: record[idx][rest] += record[idx+1][rest-arr[idx]] return record[0][aim] arr 是面值数组，其中的值都是正数且没有重复。再给定一个正数 aim。每个值都认为是一种面值，且认为张数是无限的。返回组成 aim 的方法数例如：arr = {1,2}，aim = 4方法如下：1+1+1+1、1+1+2、2+2一共就 3 种方法，所以返回 3 123456789101112131415161718192021222324def process(arr: list, idx: int, rest: int) -&gt; int: if rest &lt; 0: return 0 if idx == len(arr): return 1 if rest == 0 else 0 res = 0 for i in range(rest//arr[idx]+1): res += process(arr, idx+1, rest-(i*arr[idx])) return resdef recursion(arr: list, aim: int) -&gt; int: return process(arr, 0, aim)def dp(arr: list, aim: int) -&gt; int: record = [[0 for _ in range(aim+1)] for _ in range(len(arr)+1)] record[-1][0] = 1 for idx in range(len(arr)-1, -1, -1): for rest in range(aim+1): record[idx][rest] = record[idx+1][rest] if rest-arr[idx] &gt;= 0: record[idx][rest] += record[idx][rest - arr[idx]] return record[0][aim] arr 是货币数组，其中的值都是正数。再给定一个正数 aim。每个值都认为是一张货币，认为值相同的货币没有任何不同，返回组成 aim 的方法数例如：arr = {1,2,1,1,2,1,2}，aim = 4方法：1+1+1+1、1+1+2、2+2一共就 3 种方法，所以返回 3 12345678910111213141516171819202122232425262728293031323334def process(values: list, counts: list, idx: int, rest: int) -&gt; int: if rest &lt; 0: return 0 if idx == len(values): return 1 if rest == 0 else 0 res = 0 for i in range(counts[idx]+1): res += process(values, counts, idx+1, rest-(i*values[idx])) return resdef recursion(arr: list, aim: int) -&gt; int: data = {} for i in arr: data[i] = data[i] + 1 if data.get(i) is not None else 1 return process(list(data.keys()), list(data.values()), 0, aim)def dp(arr: list, aim: int) -&gt; int: data = {} for i in arr: data[i] = data[i] + 1 if data.get(i) is not None else 1 values = list(data.keys()) counts = list(data.values()) record = [[0 for _ in range(aim+1)] for _ in range(len(values)+1)] record[-1][0] = 1 for idx in range(len(values)-1, -1, -1): for rest in range(aim+1): record[idx][rest] = record[idx+1][rest] if rest-values[idx] &gt;= 0: record[idx][rest] += record[idx][rest-values[idx]] if rest-(counts[idx]+1)*values[idx] &gt;= 0: record[idx][rest] -= record[idx+1][rest-(counts[idx]+1)*values[idx]] return record[0][aim] 给定 5 个参数，N，M，row，col，k表示在 NM 的区域上，醉汉 Bob 初始在(row,col)位置 Bob 一共要迈出 k 步，且每步都会等概率向上下左右四个方向走一个单位任何时候 Bob 只要离开 NM 的区域，就直接死亡返回 k 步之后，Bob 还在 N*M 的区域的概率 22 暴力递归到动态规划（五）内容： 以 18 节为总纲 通过面试题进一步强化动态规划的解题套路 斜率优化技巧 题目： 给定 3 个参数，N，M，K怪兽有 N 滴血，等着英雄来砍自己英雄每一次打击，都会让怪兽流失[0…M]的血量到底流失多少？每一次在[0…M]上等概率的获得一个值求 K 次打击之后，英雄把怪兽砍死的概率 arr 是面值数组，其中的值都是正数且没有重复。再给定一个正数 aim。每个值都认为是一种面值，且认为张数是无限的。返回组成 aim 的最少货币数 给定一个正数 n，求 n 的裂开方法数，规定：后面的数不能比前面的数小比如 4 的裂开方法有：1+1+1+1、1+1+2、1+3、2+2、45 种，所以返回 5 23 暴力递归到动态规划（六）内容： 以 18 节为总纲 通过面试题进一步强化动态规划的解题套路 位信息技巧 题目： 给定一个正数数组 arr，请把 arr 中所有的数分成两个集合，尽量让两个集合的累加和接近返回最接近的情况下，较小集合的累加和 给定一个正数数组 arr，请把 arr 中所有的数分成两个集合如果 arr 长度为偶数，两个集合包含数的个数要一样多如果 arr 长度为奇数，两个集合包含数的个数必须只差一个请尽量让两个集合的累加和接近返回最接近的情况下，较小集合的累加和 N 皇后问题是指在 N*N 的棋盘上要摆 N 个皇后，要求任何两个皇后不同行、不同列， 也不在同一条斜线上 给定一个整数 n，返回 n 皇后的摆法有多少种。 n=1，返回 1n=2 或 3，2 皇后和 3 皇后问题无论怎么摆都不行，返回 0n=8，返回 92 24 窗口内最大值或最小值的更新结构内容： 滑动窗口 窗口内最大值或最小值的更新结构 用题目来学习窗口内最大值或最小值的更新结构提供的便利性 题目： 窗口内最大值或最小值更新结构的实现假设一个固定大小为 W 的窗口，依次划过 arr，返回每一次滑出状况的最大值例如，arr = [4,3,5,4,3,3,6,7], W = 3返回：[5,5,5,4,6,7] 12345678910111213141516171819202122def get_max_array(arr: list, w: int) -&gt; list: if not arr or w &lt; 1: return [] if len(arr) == 1 or len(arr) &lt; w: return [max(arr), ] r = 0 maxq = [] # 双端队列 result = [] # 存放结果 # 这里窗口两端为闭区间，[r-w+1, r] # 先进行移动，判断右侧是否纳入，判断左侧是否移除，然后计结果 while r &lt; len(arr): while maxq and arr[r] &gt;= arr[maxq[-1]]: maxq.pop() maxq.append(r) # 队列头部存的索引是否已失效，当前左边界(r-w+1) if maxq[0] &lt; r - w + 1: maxq.pop(0) # 窗口宽度(r-0+1)至少要达到 w 才开始统计 if r + 1 &gt;= w: result.append(arr[maxq[0]]) r += 1 return result 给定一个整型数组 arr，和一个整数 num某个 arr 中的子数组 sub，如果想达标，必须满足：sub 中最大值 – sub 中最小值 &lt;= num，返回 arr 中达标子数组的数量 1234567891011121314151617181920212223242526272829# 如果某个区间满足给定条件，则其子区间也满足# 如果某个区间不满足给定条件，则其父区间也不满足# 左边固定，右边移动，直到出现不满足的情况，记录满足的区间# 此时左边移动，并判断是否满足def solution(arr: list, num: int): maxq = [] minq = [] l = 0 r = 0 result = 0 while l &lt; len(arr): if r &lt; len(arr): while maxq and arr[maxq[-1]] &lt;= arr[r]: maxq.pop() maxq.append(r) while minq and arr[minq[-1]] &gt;= arr[r]: minq.pop() minq.append(r) if arr[maxq[0]] - arr[minq[0]] &lt;= num: r += 1 continue result += r-l l += 1 if maxq[0] &lt; l: maxq.pop(0) if minq[0] &lt; l: minq.pop(0) return result 加油站的良好出发点问题 动态规划中利用窗口内最大值或最小值更新结构做优化（难）arr 是货币数组，其中的值都是正数。再给定一个正数 aim。每个值都认为是一张货币，返回组成 aim 的最少货币数注意：因为是求最少货币数，所以每一张货币认为是相同或者不同就不重要了 25 单调栈内容： 单调栈的原理（无重复数+有重复数） 用题目来学习单调栈提供的便利性 题目： 单调栈实现（无重复数+有重复数） 给定一个只包含正数的数组 arr，arr 中任何一个子数组 sub，一定都可以算出(sub 累加和 )* (sub 中的最小值)是什么，那么所有子数组中，这个值最大是多少？ 给定一个非负数组 arr，代表直方图，返回直方图的最大长方形面积 给定一个二维数组 matrix，其中的值不是 0 就是 1，返回全部由 1 组成的最大子矩形内部有多少个 1（面积） 给定一个二维数组 matrix，其中的值不是 0 就是 1，返回全部由 1 组成的子矩形数量 26 单调栈相关的题目（续）、斐波那契数列的矩阵快速幂模型内容： 再讲一个单调栈相关的面试题 斐波那契数列的矩阵快速幂模型详解 题目： 给定一个数组 arr，返回所有子数组最小值的累加和 斐波那契数列矩阵乘法方式的实现 台阶方法数问题一个人可以一次往上迈 1 个台阶，也可以迈 2 个台阶，返回迈上 N 级台阶的方法数 奶牛生小牛问题第一年农场有 1 只成熟的母牛 A，往后的每年：1）每一只成熟的母牛都会生一只母牛2）每一只新出生的母牛都在出生的第三年成熟3）每一只母牛永远不会死返回 N 年后牛的数量 给定一个数 N，想象只由 0 和 1 两种字符，组成的所有长度为 N 的字符串如果某个字符串，任何 0 字符的左边都有 1 紧挨着，认为这个字符串达标返回有多少达标的字符串 用 12 的瓷砖，把 N2 的区域填满，返回铺瓷砖的方法数 27 KMP 算法 内容： KMP 算法 和 KMP 算法相关的面试题 题目： KMP 算法实现 给定两棵二叉树的头节点 head1 和 head2，返回 head1 中是否有某个子树的结构和 head2 完全一样 判断 str1 和 str2 是否互为旋转字符串 28 Manacher 算法 内容： Manacher 算法 和 Manacher 算法相关的面试题 题目： Manacher 算法实现 给定一个字符串 str，只能在 str 的后面添加字符，想让 str 整体变成回文串，返回至少要添加几个字符 29 在无序数组中找到第 K 小的数、蓄水池算法 内容： 时间复杂度 O(N)可以解决在无序数组中找到第 K 小的数，这个经典的面试题 改写快排的 partition 方法 bfprt 算法 蓄水池算法 题目： 在无序数组中找到第 K 小的数（改写快排+bfprt） 设计在无序数组中收集最大的前 K 个数字的算法（根据不同的三个时间复杂度，设计三个算法）给定一个无序数组 arr 中，长度为 N，给定一个正数 k，返回 top k 个最大的数不同时间复杂度三个方法：1）O(NlogN)2）O(N + KlogN)3）O(n + k*logk) 蓄水池算法实现假设有一个源源吐出不同球的机器，只有装下 10 个球的袋子，每一个吐出的球，要么放入袋子，要么永远扔掉如何做到机器吐出每一个球之后，所有吐出的球都等概率被放进袋子里 30 二叉树的 Morris 遍历 内容： 二叉树之前的遍历方式有空间浪费的问题 Morris 遍历时间复杂度 O(N)，额外空间复杂度 O(1)，通过利用原树中大量空闲指针的方式，达到节省空间的目的 假设来到当前节点 cur，开始时 cur 来到头节点位置1）如果 cur 没有左孩子，cur 向右移动(cur = cur.right)2）如果 cur 有左孩子，找到左子树上最右的节点 mostRight： a.如果 mostRight 的右指针指向空，让其指向 cur， 然后 cur 向左移动(cur = cur.left) b.如果 mostRight 的右指针指向 cur，让其指向 null， 然后 cur 向右移动(cur = cur.right)3）cur 为空时遍历停止 Morris 遍历实现二叉树的先序、中序、后序遍历 题目： Morris 遍历的实现 给定一棵二叉树的头节点 head，求以 head 为头的树中，最小深度是多少？ 31 线段树 内容： 线段树是一种支持范围整体修改和范围整体查询的数据结构 线段树解决的问题范畴：大范围信息可以只由左、右两侧信息加工出，而不必遍历左右两个子范围的具体状况 题目： 给定一个数组 arr，用户希望你实现如下三个方法1）void add(int L, int R, int V) : 让数组 arr[L…R]上每个数都加上 V2）void update(int L, int R, int V) : 让数组 arr[L…R]上每个数都变成 V3）int sum(int L, int R) :让返回 arr[L…R]这个范围整体的累加和怎么让这三个方法，时间复杂度都是 O(logN) 想象一下标准的俄罗斯方块游戏，X 轴是积木最终下落到底的轴线下面是这个游戏的简化版：1）只会下落正方形积木2）[a,b] -&gt; 代表一个边长为 b 的正方形积木，积木左边缘沿着 X = a 这条线从上方掉落3）认为整个 X 轴都可能接住积木，也就是说简化版游戏是没有整体的左右边界的4）没有整体的左右边界，所以简化版游戏不会消除积木，因为不会有哪一层被填满。给定一个 N*2 的二维数组 matrix，可以代表 N 个积木依次掉落，返回每一次掉落之后的最大高度Leetcode 题目：https://leetcode.com/problems/falling-squares/ 32 IndexTree、AC 自动机 内容： IndexTree1）支持区间查询2）没有线段树那么强，但是非常容易改成一维、二维、三维的结构3）只支持单点更新 AC 自动机解决在一个大字符串中，找到多个候选字符串的问题1）把所有匹配串生成一棵前缀树2）前缀树节点增加 fail 指针3）fail 指针的含义：如果必须以当前字符结尾，当前形成的路径是 str，剩下哪一个字符串的前缀和 str 的后缀 拥有最大的匹配长度。fail 指针就指向那个字符串的最后一个字符所对应的节点（迷不迷？听讲述！） 题目： IndexTree 在一维数组和二维数组上的实现 AC 自动机的实现 33 与哈希函数有关的结构 内容： 哈希函数 哈希函数的应用 布隆过滤器 一致性哈希 题目： 原理讲述为主，面试只会聊设计，所以本节无题目 34 资源限制类题目的解题套路 内容： 布隆过滤器用于集合的建立与查询，并可以节省大量空间一致性哈希解决数据服务器的负载管理问题利用并查集结构做岛问题的并行计算哈希函数可以把数据按照种类均匀分流位图解决某一范围上数字的出现情况，并可以节省大量空间利用分段统计思想、并进一步节省大量空间利用堆、外排序来做多个处理单元的结果合并 题目： 32 位无符号整数的范围是 0~4,294,967,295，现在有一个正好包含 40 亿个无符号整数的文件，可以使用最多 1GB 的内存，怎么找到出现次数最多的数？ 32 位无符号整数的范围是 0~4,294,967,295，现在有一个正好包含 40 亿个无符号整数的文件，所以在整个范围中必然存在没出现过的数，可以使用最多 1GB 的内存，怎么找到所有未出现过的数？进阶：内存限制为 3KB，但是只用找到一个没出现过的数即可 有一个包含 100 亿个 URL 的大文件，假设每个 URL 占用 64B，请找出其中所有重复的 URL补充：某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，请设计一种求出每天热门 Top100 词汇的可行办法 32 位无符号整数的范围是 0~4294967295，现在有 40 亿个无符号整数，可以使用最多 1GB 的内存，找出所有出现了两次的数 32 位无符号整数的范围是 0~4294967295，现在有 40 亿个无符号整数，可以使用最多 3K 的内存，怎么找到这 40 亿个整数的中位数？ 32 位无符号整数的范围是 0~4294967295，有一个 10G 大小的文件，每一行都装着这种类型的数字，整个文件是无序的，给你 5G 的内存空间，请你输出一个 10G 大小的文件，就是原文件所有数字排序的结果 35 有序表（上） 内容： 平衡搜索二叉树 左旋 右旋 AVL 树的节点违规 4 种类型（LL，LR，RL，RR） 题目： AVL 树的实现 36 有序表（中） 内容： size-balanced-tree 详解 skiplist 详解 聊聊红黑树 题目： size-balanced-tree 实现 skiplist 实现 37 有序表（下） 内容： 讲解有序表相关的面试题 讲解改写有序表的题目核心点 题目： 给定一个数组 arr，和两个整数 a 和 b（a&lt;=b）。求 arr 中有多少个子数组，累加和在[a,b]这个范围上。返回达标的子数组数量 有一个滑动窗口：1）L 是滑动窗口最左位置、R 是滑动窗口最右位置，一开始 LR 都在数组左侧2）任何一步都可能 R 往右动，表示某个数进了窗口3）任何一步都可能 L 往右动，表示某个数出了窗口想知道每一个窗口状态的中位数 设计一个结构包含如下两个方法：void add(int index, int num)：把 num 加入到 index 位置int get(int index) ：取出 index 位置的值void remove(int index) ：把 index 位置上的值删除要求三个方法时间复杂度 O(logN) 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）每个 people[i]=[hi, ki]表示第 i 个人的身高为 hi，前面正好有 ki 个身高大于或等于 hi 的人请你重新构造并返回输入数组 people 所表示的队列，返回的队列应该格式化为数组 queue其中 queue[j]=[hj, kj]是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。Leetcode 题目：https://leetcode.com/problems/queue-reconstruction-by-height/ 38 根据对数器找规律、根据数据量猜解法 内容： 讲解对数器找规律的解题技巧 讲解根据数据量猜解法的技巧1）C/C++，1 秒处理的指令条数为 10 的 8 次方2）Java 等语言，1~4 秒处理的指令条数为 10 的 8 次方3）这里就有大量的分析提示了 题目： 小虎去买苹果，商店只提供两种类型的塑料袋，每种类型都有任意数量1）能装下 6 个苹果的袋子2）能装下 8 个苹果的袋子小虎可以自由使用两种袋子来装苹果，但是小虎有强迫症，他要求自己使用的袋子数量必须最少，且使用的每个袋子必须装满，给定一个正整数 N，返回至少使用多少袋子。如果 N 无法让使用的每个袋子必须装满，返回-1 给定一个正整数 N，表示有 N 份青草统一堆放在仓库里，有一只牛和一只羊，牛先吃，羊后吃，它俩轮流吃草不管是牛还是羊，每一轮能吃的草量必须是：1，4，16，64…(4 的某次方)谁最先把草吃完，谁获胜，假设牛和羊都绝顶聪明，都想赢，都会做出理性的决定。根据唯一的参数 N，返回谁会赢 定义一种数：可以表示成若干（数量&gt;1）连续正数和的数比如，5=2+3，5 就是这样的数；12=3+4+5，12 就是这样的数2=1+1，2 不是这样的数，因为等号右边不是连续正数给定一个参数 N，返回是不是可以表示成若干连续正数和的数 int[] d，d[i]：i 号怪兽的能力int[] p，p[i]：i 号怪兽要求的钱开始时你的能力是 0，你的目标是从 0 号怪兽开始，通过所有的怪兽。如果你当前的能力，小于 i 号怪兽的能力，你必须付出 p[i]的钱，贿赂这个怪兽，然后怪兽就会加入你他的能力直接累加到你的能力上；如果你当前的能力，大于等于 i 号怪兽的能力你可以选择直接通过，你的能力并不会下降，你也可以选择贿赂这个怪兽，然后怪兽就会加入你他的能力直接累加到你的能力上返回通过所有的怪兽，需要花的最小钱数（课上会给出不同的数据量描述） 39 根据数据量猜解法（续）、分治技巧、卡特兰数 内容： 继续熟悉根据数据量猜解法 讲解分治法 讲解卡特兰数（课上证明的时候有小错，在 40 节开始处修正了） 题目： 给定一个非负数组 arr，和一个正数 m，返回 arr 的所有子序列中累加和%m 之后的最大值 牛牛家里一共有 n 袋零食, 第 i 袋零食体积为 v[i]，背包容量为 w，牛牛想知道在总体积不超过背包容量的情况下,一共有多少种零食放法，体积为 0 也算一种放法1 &lt;= n &lt;= 30, 1 &lt;= w &lt;= 2 * 10^9，v[I] (0 &lt;= v[i] &lt;= 10^9） 假设给你 N 个 0，和 N 个 1，你必须用全部数字拼序列，返回有多少个序列满足任何前缀串，1 的数量都不少于 0 的数量 有 N 个二叉树节点，每个节点彼此之间无任何差别，返回由 N 个二叉树节点，组成的不同结构数量是多少？ 题目补充： arr 中的值可能为正，可能为负，可能为 0，自由选择 arr 中的数字，能不能累加得到 sum（多种做法） 40 子数组达到规定累加和的最大长度系列问题、矩阵处理技巧题 内容： 修正了 39 节卡特兰数讲解时的一个小错误 熟悉子数组达到规定累加和的三个模型（正、有正有负有 0、累加和&lt;=K） 矩阵处理技巧的宏观调度 coding 技巧 题目： 给定一个正整数组成的无序数组 arr，给定一个正整数值 K，找到 arr 的所有子数组里，哪个子数组的累加和等于 K并且是长度最大的，返回其长度 给定一个整数组成的无序数组 arr，值可能正、可能负、可能 0，给定一个整数值 K找到 arr 的所有子数组里，哪个子数组的累加和等于 K，并且是长度最大的，返回其长度 给定一个整数组成的无序数组 arr，值可能正、可能负、可能 0，给定一个整数值 K找到 arr 的所有子数组里，哪个子数组的累加和&lt;=K，并且是长度最大的，返回其长度 给定一个数组 arr，给定一个值 v，求子数组平均值小于等于 v 的最长子数组长度 给定一个正方形矩阵 matrix，原地调整成顺时针 90 度转动的样子 给定一个正方形或者长方形矩阵 matrix，实现转圈打印 给定一个正方形或者长方形矩阵 matrix，实现 zigzag 打印 转圈打印星号*问题 41 四边形不等式技巧（上） 内容： 区间划分问题中的划分点不回退现象 四边形不等式技巧特征1，两个可变参数的区间划分问题2，每个格子有枚举行为3，当两个可变参数固定一个，另一个参数和答案之间存在单调性关系4，而且两组单调关系是反向的：(升 升，降 降) (升 降，降 升)5，能否获得指导枚举优化的位置对：上+右，或者，左+下 四边形不等式技巧注意点1，不要证明！用对数器验证！2，枚举的时候面对最优答案相等的时候怎么处理？用对数器都试试！3，可以把时间复杂度降低一阶O(N^3) -&gt; O(N^2)O(N^2 _ M) -&gt; O(N _ M)O(N _ M^2) -&gt; O(N _ M)4，四边形不等式有些时候是最优解，有些时候不是不是的原因：尝试思路，在根儿上不够好 题目： 给定一个非负数组 arr，长度为 N，那么有 N-1 种方案可以把 arr 切成左右两部分每一种方案都有，min{左部分累加和，右部分累加和}求这么多方案中，min{左部分累加和，右部分累加和}的最大值是多少？整个过程要求时间复杂度 O(N) 把题目一中提到的，min{左部分累加和，右部分累加和}，定义为 S(N-1)，也就是说：S(N-1)：在 arr[0…N-1]范围上，做最优划分所得到的 min{左部分累加和，右部分累加和}的最大值现在要求返回一个长度为 N 的 s 数组，s[i] =在 arr[0…i]范围上，做最优划分所得到的 min{左部分累加和，右部分累加和}的最大值得到整个 s 数组的过程，做到时间复杂度 O(N) 摆放着 n 堆石子。现要将石子有次序地合并成一堆，规定每次只能选相邻的 2 堆石子合并成新的一堆并将新的一堆石子数记为该次合并的得分，求出将 n 堆石子合并成一堆的最小得分（或最大得分）合并方案 给定一个整型数组 arr，数组中的每个值都为正数，表示完成一幅画作需要的时间，再给定一个整数 num表示画匠的数量，每个画匠只能画连在一起的画作所有的画家并行工作，返回完成所有的画作需要的最少时间arr=[3,1,4]，num=2。最好的分配方式为第一个画匠画 3 和 1，所需时间为 4第二个画匠画 4，所需时间为 4所以返回 4arr=[1,1,1,4,3]，num=3最好的分配方式为第一个画匠画前三个 1，所需时间为 3第二个画匠画 4，所需时间为 4第三个画匠画 3，所需时间为 3返回 4 42 四边形不等式技巧（下） 内容： 继续熟悉四边形不等式 展示好的尝试是最关键的 题目： 一条直线上有居民点，邮局只能建在居民点上给定一个有序正数数组 arr，每个值表示 居民点的一维坐标，再给定一个正数 num，表示邮局数量选择 num 个居民点建立 num 个邮局，使所有的居民点到最近邮局的总距离最短，返回最短的总距离arr=[1,2,3,4,5,1000]，num=2第一个邮局建立在 3 位置，第二个邮局建立在 1000 位置那么 1 位置到邮局的距离为 2，2 位置到邮局距离为 1，3 位置到邮局的距离为 0，4 位置到邮局的距离为 1，5 位置到邮局的距离为 21000 位置到邮局的距离为 0这种方案下的总距离为 6，其他任何方案的总距离都不会比该方案的总距离更短，所以返回 6 一座大楼有 0N 层，地面算作第 0 层，最高的一层为第 N 层已知棋子从第 0 层掉落肯定不会摔碎，从第 i 层掉落可能会摔碎，也可能不会摔碎(1≤i≤N)给定整数 N 作为楼层数，再给定整数 K 作为棋子数返回如果想找到棋子不会摔碎的最高层数，即使在最差的情况下扔的最少次数一次只能扔一个棋子 N=10，K=1 返回 10 因为只有 1 棵棋子，所以不得不从第 1 层开始一直试到第 10 层在最差的情况下，即第 10 层是不会摔坏的最高层，最少也要扔 10 次 N=3，K=2 返回 2 先在 2 层扔 1 棵棋子，如果碎了试第 1 层，如果没碎试第 3 层 N=105，K=2 返回 14 第一个棋子先在 14 层扔，碎了则用仅存的一个棋子试 113若没碎，第一个棋子继续在 27 层扔，碎了则用仅存的一个棋子试 1526 若没碎，第一个棋子继续在 39 层扔，碎了则用仅存的一个棋子试 2838若没碎，第一个棋子继续在 50 层扔，碎了则用仅存的一个棋子试 4049 若没碎，第一个棋子继续在 60 层扔，碎了则用仅存的一个棋子试 5159若没碎，第一个棋子继续在 69 层扔，碎了则用仅存的一个棋子试 6168 若没碎，第一个棋子继续在 77 层扔，碎了则用仅存的一个棋子试 7076若没碎，第一个棋子继续在 84 层扔，碎了则用仅存的一个棋子试 7883 若没碎，第一个棋子继续在 90 层扔，碎了则用仅存的一个棋子试 8589若没碎，第一个棋子继续在 95 层扔，碎了则用仅存的一个棋子试 9194 若没碎，第一个棋子继续在 99 层扔，碎了则用仅存的一个棋子试 9698若没碎，第一个棋子继续在 102 层扔，碎了则用仅存的一个棋子试 100、101若没碎，第一个棋子继续在 104 层扔，碎了则用仅存的一个棋子试 103若没碎，第一个棋子继续在 105 层扔，若到这一步还没碎，那么 105 便是结果 43 状态压缩的动态规划 内容： 动态规划的状态压缩技巧 题目： 在”100 game”这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和先使得累计整数和达到或超过 100 的玩家，即为胜者，如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;= 100给定一个整数 maxChoosableInteger （整数池中可选择的最大数）和另一个整数 desiredTotal（累计和）判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）你可以假设 maxChoosableInteger 不会大于 20， desiredTotal 不会大于 300。Leetcode 题目：https://leetcode.com/problems/can-i-win/ TSP 问题有 N 个城市，任何两个城市之间的都有距离，任何一座城市到自己的距离都为 0所有点到点的距离都存在一个 N*N 的二维数组 matrix 里，也就是整张图由邻接矩阵表示现要求一旅行商从 k 城市出发必须经过每一个城市且只在一个城市逗留一次，最后回到出发的 k 城参数给定一个 matrix，给定 k。返回总距离最短的路的距离 铺砖问题（最优解其实是轮廓线 dp，但是这个解法对大厂刷题来说比较难，掌握课上的解法即可）你有无限的 12 的砖块，要铺满 MN 的区域，不同的铺法有多少种? 44 DC3 生成后缀数组详解 内容： 后缀数组 介绍用 DC3 算法生成后缀数组的流程 题目： 给你一个字符串 s，找出它的所有子串并按字典序排列，返回排在最后的那个子串Leetcode 题目：https://leetcode.com/problems/last-substring-in-lexicographical-order/ DC3 算法的实现（完全根据论文描述） 45 后缀数组解决的面试题 内容： 通过题目进一步熟悉 DC3 算法 通过 DC3 算法得到 height 数组 题目： 给定两个字符串 str1 和 str2，想把 str2 整体插入到 str1 中的某个位置，形成最大的字典序，返回字典序最大的结果 给两个长度分别为 M 和 N 的整型数组 nums1 和 nums2，其中每个值都不大于 9，再给定一个正数 K。 你可以在 nums1 和 nums2 中挑选数字，要求一共挑选 K 个，并且要从左到右挑。返回所有可能的结果中，代表最大数字的结果 最长公共子串问题是面试常见题目之一，假设 str1 长度 N，str2 长度 M一般在面试场上回答出 O(NM)的解法已经是比较优秀了因为得到 O(NM)的解法，就已经需要用到动态规划了但其实这个问题的最优解是 O(N+M)，需要用到后缀数组+height 数组课上将对本题解法代码进行详解 46 动态规划猜法中和外部信息简化的相关问题（上）、哈夫曼树 内容： 以 18 节做总纲 有些动态规划面试题，需要很好的设计参数，这种设计方式都有”外部信息简化”的特征 哈夫曼树 题目： 有 n 个气球，编号为 0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] _ nums[i] _ nums[i + 1] 枚硬币这里的 i-1 和 i+1 代表和 i 相邻的、没有被戳爆的！两个气球的序号如果 i-1 或 i+1 超出了数组的边界，那么就当它是一个数字为 1 的气球求所能获得硬币的最大数量Leetcode 题目：https://leetcode.com/problems/burst-balloons/ 给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色，你将经过若干轮操作去去掉盒子直到所有的盒子都去掉为止，每一轮你可以移除具有相同颜色的连续 k 个盒子（k &gt;= 1）这样一轮之后你将得到 k * k 个积分，当你将所有盒子都去掉之后，求你能获得的最大积分和Leetcode 题目：https://leetcode.com/problems/remove-boxes/ 如果一个字符相邻的位置没有相同字符，那么这个位置的字符出现不能被消掉比如:”ab”，其中 a 和 b 都不能被消掉如果一个字符相邻的位置有相同字符，就可以一起消掉比如:”abbbc”，中间一串的 b 是可以被消掉的，消除之后剩下”ac”某些字符如果消掉了，剩下的字符认为重新靠在一起给定一个字符串，你可以决定每一步消除的顺序，目标是请尽可能多的消掉字符，返回最少的剩余字符数量比如：”aacca”, 如果先消掉最左侧的”aa”，那么将剩下”cca”，然后把”cc”消掉，剩下的”a”将无法再消除，返回 1但是如果先消掉中间的”cc”，那么将剩下”aaa”，最后都消掉就一个字符也不剩了，返回 0，这才是最优解。再比如：”baaccabb”，如果先消除最左侧的两个 a，剩下”bccabb”，如果再消除最左侧的两个 c，剩下”babb”，最后消除最右侧的两个 b，剩下”ba”无法再消除，返回 2而最优策略是：如果先消除中间的两个 c，剩下”baaabb”，如果再消除中间的三个 a，剩下”bbb”，最后消除三个 b，不留下任何字符，返回 0，这才是最优解 给定一个数组 arr，和一个正数 M，返回在 arr 的子数组在长度不超过 M 的情况下，最大的累加和 哈夫曼树的实现 47 动态规划猜法中和外部信息简化的相关问题（下）、最大网络流算法之 Dinic 算法 内容： 进一步解决带有”外部信息简化”特征的动态规划 Dinic 算法 题目： 有台奇怪的打印机有以下两个特殊要求：打印机每次只能打印由同一个字符组成的序列。每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。给你一个字符串 s，你的任务是计算这个打印机打印它需要的最少打印次数。Leetcode 题目：https://leetcode.com/problems/strange-printer/ 整型数组 arr 长度为 n(3 &lt;= n &lt;= 10^4)，最初每个数字是&lt;=200 的正数且满足如下条件： 0 位置的要求：arr[0]&lt;=arr[1] n-1 位置的要求：arr[n-1]&lt;=arr[n-2] 中间 i 位置的要求：arr[i]&lt;=max(arr[i-1],arr[i+1])但是在 arr 有些数字丢失了，比如 k 位置的数字之前是正数，丢失之后 k 位置的数字为 0请你根据上述条件，计算可能有多少种不同的 arr 可以满足以上条件比如 [6,0,9] 只有还原成 [6,9,9]满足全部三个条件，所以返回 1，即[6,9,9]达标 Dinic 算法详解测试链接：https://lightoj.com/problem/internet-bandwidth","link":"/2023/03/06/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"python","slug":"python","link":"/tags/python/"}],"categories":[],"pages":[{"title":"about","text":"","link":"/about/index.html"}]}