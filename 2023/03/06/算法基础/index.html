<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>算法基础 - Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="这篇文章涵盖了算法的基本概念以及常见数据结构与算法，刷题之前可以通过这部分内容巩固基础。"><meta property="og:type" content="blog"><meta property="og:title" content="算法基础"><meta property="og:url" content="https://aikenzh.github.io/2023/03/06/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="Blog"><meta property="og:description" content="这篇文章涵盖了算法的基本概念以及常见数据结构与算法，刷题之前可以通过这部分内容巩固基础。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://aikenzh.github.io/img/og_image.png"><meta property="article:published_time" content="2023-03-06T11:39:08.000Z"><meta property="article:modified_time" content="2023-03-24T14:52:09.478Z"><meta property="article:author" content="AikenZh"><meta property="article:tag" content="Algorithm"><meta property="article:tag" content="python"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://aikenzh.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://aikenzh.github.io/2023/03/06/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},"headline":"算法基础","image":["https://aikenzh.github.io/img/og_image.png"],"datePublished":"2023-03-06T11:39:08.000Z","dateModified":"2023-03-24T14:52:09.478Z","author":{"@type":"Person","name":"AikenZh"},"publisher":{"@type":"Organization","name":"Blog","logo":{"@type":"ImageObject","url":"https://aikenzh.github.io/img/logo.svg"}},"description":"这篇文章涵盖了算法的基本概念以及常见数据结构与算法，刷题之前可以通过这部分内容巩固基础。"}</script><link rel="canonical" href="https://aikenzh.github.io/2023/03/06/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-06T11:39:08.000Z" title="3/6/2023, 7:39:08 PM">2023-03-06</time>发表</span><span class="level-item"><time dateTime="2023-03-24T14:52:09.478Z" title="3/24/2023, 10:52:09 PM">2023-03-24</time>更新</span><span class="level-item">2 小时读完 (大约17723个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">算法基础</h1><div class="content"><h1 id="时间复杂度、空间复杂度"><a href="#时间复杂度、空间复杂度" class="headerlink" title="时间复杂度、空间复杂度"></a>时间复杂度、空间复杂度</h1><p>内容：略</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>描述：略</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>描述：略</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>描述：略</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_recursion</span>(<span class="params">ilist: <span class="built_in">list</span>, inum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ilist:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ilist) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> ilist.pop() == inum</span><br><span class="line">    m = <span class="built_in">len</span>(ilist) &gt;&gt; <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> inum == ilist[m]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> inum &gt; ilist[m]:</span><br><span class="line">        <span class="keyword">return</span> binary_search_recursion(ilist[m+<span class="number">1</span>:], inum)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> binary_search_recursion(ilist[:m], inum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">ilist: <span class="built_in">list</span>, inum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ilist:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ilist) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> ilist.pop() == inum</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = <span class="built_in">len</span>(ilist) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        m = l + ((r-l) &gt;&gt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> inum == ilist[m]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> inum &gt; ilist[m]:</span><br><span class="line">            l = m + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = m - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> inum == ilist[l]</span><br></pre></td></tr></table></figure>

<p>应用：</p>
<ol>
<li>有序数组中找到&gt;&#x3D;num 最左的位置</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>有序数组中找到&lt;&#x3D;num 最右的位置 ​</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>局部最小值问题<br>定义何为局部最小值：<br>arr[0] &lt; arr[1]，0 位置是局部最小；<br>arr[N-1] &lt; arr[N-2]，N-1 位置是局部最小；<br>arr[i-1] &gt; arr[i] &lt; arr[i+1]，i 位置是局部最小；<br>给定一个数组 arr，已知任何两个相邻的数都不相等，找到随便一个局部最小位置返回</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h1><p>内容： 异或运算满足交换律与结合律，即<code>a ^ b = b ^ a</code>，<code>a ^ b ^ c = a ^ (b ^ c)</code></p>
<p>题目：</p>
<p>不用额外变量交换两个数的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line">a = a ^ b <span class="comment"># 此时 a = 10 ^ 20</span></span><br><span class="line">b = a ^ b <span class="comment"># 相当于 (10 ^ 20) ^ 20 = 10</span></span><br><span class="line">a = a ^ b <span class="comment"># 相当于 (10 ^ 20) ^ 10 = 20</span></span><br></pre></td></tr></table></figure>

<p>不用额外变量交换数组中两个数的值</p>
<p>一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数</p>
<p>怎么把一个 int 类型的数，提取出二进制中最右侧的 1 来</p>
<p>一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数</p>
<p>一个数组中有一种数出现 K 次，其他数都出现了 M 次，<br>已知 M &gt; 1，K &lt; M，找到出现了 K 次的数<br>要求额外空间复杂度 O(1)，时间复杂度 O(N)</p>
<h1 id="03-单双链表、栈和队列、递归和-Master-公式、哈希表和有序表的使用和性能"><a href="#03-单双链表、栈和队列、递归和-Master-公式、哈希表和有序表的使用和性能" class="headerlink" title="03 单双链表、栈和队列、递归和 Master 公式、哈希表和有序表的使用和性能"></a>03 单双链表、栈和队列、递归和 Master 公式、哈希表和有序表的使用和性能</h1><p>内容：</p>
<p>单链表、双链表</p>
<p>栈、队列</p>
<p>递归的物理实质</p>
<p>评估递归复杂度的 Master 公式</p>
<p>哈希表的使用和性能</p>
<p>有序表的使用和性能</p>
<p>题目：</p>
<p>反转单链表、反转双链表</p>
<p>在链表中删除指定值的所有节点</p>
<p>用双链表实现栈和队列</p>
<p>用环形数组实现栈和队列</p>
<p>实现有 getMin 功能的栈</p>
<p>两个栈实现队列</p>
<p>两个队列实现栈</p>
<p>用递归行为得到数组中的最大值，并用 master 公式来估计时间复杂度</p>
<p>哈希表和有序表使用的 code 展示</p>
<h1 id="04-归并排序及其常见面试题"><a href="#04-归并排序及其常见面试题" class="headerlink" title="04 归并排序及其常见面试题"></a>04 归并排序及其常见面试题</h1><p>内容：</p>
<p>归并排序</p>
<p>题目：</p>
<p>归并排序的递归和非递归实现</p>
<p>在一个数组中，一个数左边比它小的数的总和，叫该数的小和<br>所有数的小和累加起来，叫数组小和<br>例子： [1,3,4,2,5]<br>1 左边比 1 小的数：没有<br>3 左边比 3 小的数：1<br>4 左边比 4 小的数：1、3<br>2 左边比 2 小的数：1<br>5 左边比 5 小的数：1、3、4、 2<br>所以数组的小和为 1+1+3+1+1+3+4+2&#x3D;16<br>给定一个数组 arr，求数组小和</p>
<p>在一个数组中，任何一个前面的数 a，和任何一个后面的数 b，如果(a,b)是降序的，就称为降序对<br>给定一个数组 arr，求数组的降序对总数量</p>
<p>在一个数组中，对于任何一个数 num，求有多少个(后面的数*2)依然&lt;num，返回总个数<br>比如：[3,1,7,0,2]<br>3 的后面有：1，0<br>1 的后面有：0<br>7 的后面有：0，2<br>0 的后面没有<br>2 的后面没有<br>所以总共有 5 个</p>
<h1 id="05-归并排序面试题-续-、快速排序"><a href="#05-归并排序面试题-续-、快速排序" class="headerlink" title="05 归并排序面试题(续)、快速排序"></a>05 归并排序面试题(续)、快速排序</h1><p>内容：</p>
<p>再来一个归并排序面试题</p>
<p>荷兰国旗问题</p>
<p>快速排序 1.0</p>
<p>快速排序 2.0</p>
<p>快速排序 3.0</p>
<p>题目：</p>
<p>给定一个数组 arr，两个整数 lower 和 upper，<br>返回 arr 中有多少个子数组的累加和在[lower,upper]范围上<br>Leetcode 题目：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/count-of-range-sum/">https://leetcode.com/problems/count-of-range-sum/</a></p>
<p>荷兰国旗问题的实现</p>
<p>快速排序从 1.0 到 3.0 的实现</p>
<p>快速排序的递归实现和非递归实现</p>
<p>code 附加，双向链表进行快速排序的 code 实现</p>
<h1 id="06-比较器、堆结构、堆排序"><a href="#06-比较器、堆结构、堆排序" class="headerlink" title="06 比较器、堆结构、堆排序"></a>06 比较器、堆结构、堆排序</h1><p>内容：</p>
<p>比较器</p>
<p>堆结构</p>
<p>堆排序</p>
<p>建立大根堆的两种方式，从上到下、从下到上，及其复杂度分析</p>
<p>题目：</p>
<p>比较器使用的 code 展示</p>
<p>堆结构的实现</p>
<p>堆排序的实现</p>
<p>b 已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过 k<br>k 相对于数组长度来说是比较小的。请选择一个合适的排序策略，对这个数组进行排序。</p>
<h1 id="07-和堆有关的面试题、加强堆结构"><a href="#07-和堆有关的面试题、加强堆结构" class="headerlink" title="07 和堆有关的面试题、加强堆结构"></a>07 和堆有关的面试题、加强堆结构</h1><p>内容：</p>
<p>线段最大重合问题</p>
<p>加强堆的实现</p>
<p>题目：</p>
<p>给定很多线段，每个线段都有两个数[start, end]，<br>表示线段开始位置和结束位置，左右都是闭区间<br>规定：<br>1）线段的开始和结束位置一定都是整数值<br>2）线段重合区域的长度必须&gt;&#x3D;1<br>返回线段最多重合区域中，包含了几条线段</p>
<p>加强堆的实现、注意点解析</p>
<p>做一个加强堆的题目，给定一个整型数组，int[] arr；和一个布尔类型数组，boolean[] op<br>两个数组一定等长，假设长度为 N，arr[i]表示客户编号，op[i]表示客户操作<br>arr&#x3D; [3,3,1,2,1,2,5…<br>op &#x3D; [T,T,T,T,F,T,F…<br>依次表示：<br>3 用户购买了一件商品<br>3 用户购买了一件商品<br>1 用户购买了一件商品<br>2 用户购买了一件商品<br>1 用户退货了一件商品<br>2 用户购买了一件商品<br>5 用户退货了一件商品…<br>一对 arr[i]和 op[i]就代表一个事件：<br>用户号为 arr[i]，op[i] &#x3D;&#x3D; T 就代表这个用户购买了一件商品<br>op[i] &#x3D;&#x3D; F 就代表这个用户退货了一件商品<br>现在你作为电商平台负责人，你想在每一个事件到来的时候，<br>都给购买次数最多的前 K 名用户颁奖。<br>所以每个事件发生后，你都需要一个得奖名单（得奖区）。<br>得奖系统的规则：<br>1，如果某个用户购买商品数为 0，但是又发生了退货事件，<br> 则认为该事件无效，得奖名单和上一个事件发生后一致，例子中的 5 用户<br>2，某用户发生购买商品事件，购买商品数+1，发生退货事件，购买商品数-1<br>3，每次都是最多 K 个用户得奖，K 也为传入的参数<br> 如果根据全部规则，得奖人数确实不够 K 个，那就以不够的情况输出结果<br>4，得奖系统分为得奖区和候选区，任何用户只要购买数&gt;0，<br> 一定在这两个区域中的一个<br>5，购买数最大的前 K 名用户进入得奖区，<br> 在最初时如果得奖区没有到达 K 个用户，那么新来的用户直接进入得奖区<br>6，如果购买数不足以进入得奖区的用户，进入候选区<br>7，如果候选区购买数最多的用户，已经足以进入得奖区，<br> 该用户就会替换得奖区中购买数最少的用户（大于才能替换），<br> 如果得奖区中购买数最少的用户有多个，就替换最早进入得奖区的用户<br> 如果候选区中购买数最多的用户有多个，机会会给最早进入候选区的用户<br>8，候选区和得奖区是两套时间，<br> 因用户只会在其中一个区域，所以只会有一个区域的时间，另一个没有<br> 从得奖区出来进入候选区的用户，得奖区时间删除，<br> 进入候选区的时间就是当前事件的时间（可以理解为 arr[i]和 op[i]中的 i）<br> 从候选区出来进入得奖区的用户，候选区时间删除，<br> 进入得奖区的时间就是当前事件的时间（可以理解为 arr[i]和 op[i]中的 i）<br>9，如果某用户购买数&#x3D;&#x3D;0，不管在哪个区域都离开，区域时间删除，<br> 离开是指彻底离开，哪个区域也不会找到该用户<br> 如果下次该用户又发生购买行为，产生&gt;0 的购买数，<br> 会再次根据之前规则回到某个区域中，进入区域的时间重记<br>请遍历 arr 数组和 op 数组，遍历每一步输出一个得奖名单<br>public List&lt;List<Integer>&gt; topK (int[] arr, boolean[] op, int k)</p>
<h1 id="08-前缀树、不基于比较的排序（计数排序、基数排序）、排序算法的稳定性"><a href="#08-前缀树、不基于比较的排序（计数排序、基数排序）、排序算法的稳定性" class="headerlink" title="08 前缀树、不基于比较的排序（计数排序、基数排序）、排序算法的稳定性"></a>08 前缀树、不基于比较的排序（计数排序、基数排序）、排序算法的稳定性</h1><p>内容：</p>
<p>前缀树</p>
<p>计数排序</p>
<p>基数排序</p>
<p>排序算法的稳定性</p>
<p>题目：</p>
<p>前缀树实现</p>
<p>计数排序</p>
<p>基数排序</p>
<h1 id="09-排序算法大总结、链表及其相关面试题"><a href="#09-排序算法大总结、链表及其相关面试题" class="headerlink" title="09 排序算法大总结、链表及其相关面试题"></a>09 排序算法大总结、链表及其相关面试题</h1><p>内容：</p>
<p>排序算法总结</p>
<p>排序算法常见的坑</p>
<p>工程上对排序的常见改进</p>
<p>链表面试题的常见技巧</p>
<p>题目：</p>
<p>输入链表头节点，奇数长度返回中点，偶数长度返回上中点<br>输入链表头节点，奇数长度返回中点，偶数长度返回下中点<br>输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个<br>输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个</p>
<p>给定一个单链表的头节点 head，请判断该链表是否为回文结构</p>
<p>给定一个单链表的头节点 head，给定一个整数 n，将链表按 n 划分成左边&lt;n、中间&#x3D;&#x3D;n、右边&gt;n</p>
<p>一种特殊的单链表节点类描述如下<br>class Node {<br>int value;<br>Node next;<br>Node rand;<br>Node(int val) { value &#x3D; val; }<br>}<br>rand 指针是单链表节点结构中新增的指针，rand 可能指向链表中的任意一个节点，也可能指向 null<br>给定一个由 Node 节点类型组成的无环单链表的头节点 head，请实现一个函数完成这个链表的复制<br>返回复制的新链表的头节点，要求时间复杂度 O(N)，额外空间复杂度 O(1)</p>
<h1 id="10-链表相关面试题（续）、二叉树的常见遍历"><a href="#10-链表相关面试题（续）、二叉树的常见遍历" class="headerlink" title="10 链表相关面试题（续）、二叉树的常见遍历"></a>10 链表相关面试题（续）、二叉树的常见遍历</h1><p>内容：</p>
<p>单链表的相交节点系列问题</p>
<p>一种看似高效其实搞笑的节点删除方式</p>
<p>二叉树的中序、先序、后序遍历</p>
<p>题目：</p>
<p>给定两个可能有环也可能无环的单链表，头节点 head1 和 head2<br>请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交返回 null<br>要求如果两个链表长度之和为 N，时间复杂度请达到 O(N)，额外空间复杂度请达到 O(1)</p>
<p>能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？</p>
<p>二叉树先序、中序、后序的递归遍历和递归序</p>
<p>二叉树先序、中序、后序的非递归遍历</p>
<h1 id="11-二叉树常见面试题和二叉树的递归套路（上）"><a href="#11-二叉树常见面试题和二叉树的递归套路（上）" class="headerlink" title="11 二叉树常见面试题和二叉树的递归套路（上）"></a>11 二叉树常见面试题和二叉树的递归套路（上）</h1><p>内容：</p>
<p>通过题目来熟悉二叉树的解题技巧</p>
<p>题目：</p>
<p>二叉树的按层遍历</p>
<p>二叉树的序列化和反序列化</p>
<p>N 叉树如何通过二叉树来序列化、并完成反序列化<br>Leetcode 题目：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/encode-n-ary-tree-to-binary-tree/">https://leetcode.com/problems/encode-n-ary-tree-to-binary-tree/</a></p>
<p>打印二叉树的函数设计</p>
<p>求二叉树的最大宽度</p>
<p>求二叉树某个节点的后继节点<br>二叉树结构如下定义：<br>Class Node {<br> V value;<br> Node left;<br> Node right;<br> Node parent;<br>}<br>给你二叉树中的某个节点，返回该节点的后继节点</p>
<p>折纸问题<br>请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折 1 次，压出折痕后展开<br>此时折痕是凹下去的，即折痕突起的方向指向纸条的背面<br>如果从纸条的下边向上方连续对折 2 次，压出折痕后展开<br>此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。<br>给定一个输入参数 N，代表纸条都从下边向上方连续对折 N 次<br>请从上到下打印所有折痕的方向。<br>N&#x3D;1 时，打印: down<br>N&#x3D;2 时，打印: down down up</p>
<h1 id="12-二叉树常见面试题和二叉树的递归套路（中）"><a href="#12-二叉树常见面试题和二叉树的递归套路（中）" class="headerlink" title="12 二叉树常见面试题和二叉树的递归套路（中）"></a>12 二叉树常见面试题和二叉树的递归套路（中）</h1><p>内容：</p>
<p>通过题目来熟悉二叉树的解题技巧</p>
<p>介绍二叉树的递归套路<br>1）假设以 X 节点为头，假设可以向 X 左树和 X 右树要任何信息<br>2）在上一步的假设下，讨论以 X 为头节点的树，得到答案的可能性（最重要）<br>3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息<br>4）把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息 S<br>5）递归函数都返回 S，每一棵子树都这么要求<br>6）写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息</p>
<p>题目：</p>
<p>判断二叉树是不是搜索二叉树</p>
<p>判断二叉树是不是平衡二叉树</p>
<p>判断二叉树是不是满二叉树</p>
<p>给定一棵二叉树的头节点 head，返回这颗二叉树中最大的二叉搜索子树的大小</p>
<p>给定一棵二叉树的头节点 head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离</p>
<h1 id="13-二叉树常见面试题和二叉树的递归套路（下）、贪心算法"><a href="#13-二叉树常见面试题和二叉树的递归套路（下）、贪心算法" class="headerlink" title="13 二叉树常见面试题和二叉树的递归套路（下）、贪心算法"></a>13 二叉树常见面试题和二叉树的递归套路（下）、贪心算法</h1><p>内容：</p>
<p>二叉树递归套路继续实践</p>
<p>一道贪心算法从头到尾的完整做法</p>
<p>解决贪心题目的重要技巧，即对数器来验证脑洞</p>
<p>再次强调对数器的重要性</p>
<p>题目：</p>
<p>判断二叉树是不是完全二叉树（一般方法解决、递归套路解决）</p>
<p>给定一棵二叉树的头节点 head，返回这颗二叉树中最大的二叉搜索子树的头节点</p>
<p>给定一棵二叉树的头节点 head，和另外两个节点 a 和 b，返回 a 和 b 的最低公共祖先</p>
<p>派对的最大快乐值<br> 员工信息的定义如下:<br>class Employee {<br> public int happy; &#x2F;&#x2F; 这名员工可以带来的快乐值<br> List<Employee> subordinates; &#x2F;&#x2F; 这名员工有哪些直接下级<br>}<br>公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树<br>树的头节点是公司唯一的老板，除老板之外的每个员工都有唯一的直接上级<br>叶节点是没有任何下属的基层员工(subordinates 列表为空)，除基层员工外每个员工都有一个或多个直接下级<br>这个公司现在要办 party，你可以决定哪些员工来，哪些员工不来，规则：<br>1.如果某个员工来了，那么这个员工的所有直接下级都不能来<br>2.派对的整体快乐值是所有到场员工快乐值的累加<br>3.你的目标是让派对的整体快乐值尽量大<br>给定一棵多叉树的头节点 boss，请返回派对的最大快乐值。</p>
<p>给定一个由字符串组成的数组 strs，必须把所有的字符串拼接起来，返回所有可能的拼接结果中字典序最小的结果</p>
<h1 id="14-贪心算法（续）、并查集"><a href="#14-贪心算法（续）、并查集" class="headerlink" title="14 贪心算法（续）、并查集"></a>14 贪心算法（续）、并查集</h1><p>内容：</p>
<p>贪心算法继续实战</p>
<p>并查集详解</p>
<p>题目：</p>
<p>给定一个字符串 str，只由’X’和’.’两种字符构成<br>‘X’表示墙，不能放灯，也不需要点亮；’.’表示居民点，可以放灯，需要点亮<br>如果灯放在 i 位置，可以让 i-1，i 和 i+1 三个位置被点亮<br>返回如果点亮 str 中所有需要点亮的位置，至少需要几盏灯</p>
<p>一块金条切成两半，是需要花费和长度数值一样的铜板<br>比如长度为 20 的金条，不管怎么切都要花费 20 个铜板，一群人想整分整块金条，怎么分最省铜板?<br>例如，给定数组{10,20,30}，代表一共三个人，整块金条长度为 60，金条要分成 10，20，30 三个部分。<br>如果先把长度 60 的金条分成 10 和 50，花费 60；再把长度 50 的金条分成 20 和 30，花费 50；一共花费 110 铜板<br>但如果先把长度 60 的金条分成 30 和 30，花费 60；再把长度 30 金条分成 10 和 20，花费 30；一共花费 90 铜板<br> 输入一个数组，返回分割的最小代价</p>
<p>一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲，给你每一个项目开始的时间和结束的时间<br>你来安排宣讲的日程，要求会议室进行的宣讲的场次最多，返回最多的宣讲场次</p>
<p>输入正数数组 costs、正数数组 profits、正数 K 和正数 M<br>costs[i]表示 i 号项目的花费<br>profits[i]表示 i 号项目在扣除花费之后还能挣到的钱(利润)<br>K 表示你只能串行的最多做 k 个项目<br>M 表示你初始的资金<br>说明：每做完一个项目，马上获得的收益，可以支持你去做下一个项目，不能并行的做项目。<br>输出：最后获得的最大钱数</p>
<p>并查集的实现</p>
<h1 id="15-并查集相关的常见面试题"><a href="#15-并查集相关的常见面试题" class="headerlink" title="15 并查集相关的常见面试题"></a>15 并查集相关的常见面试题</h1><p>内容：</p>
<p>通过解答实际出现的面试题来体会并查集的优势、熟悉并查集的使用</p>
<p>题目：</p>
<p>一群朋友中，有几个不相交的朋友圈<br>Leetcode 题目：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/friend-circles/">https://leetcode.com/problems/friend-circles/</a></p>
<p>岛问题（递归解法 + 并查集解法 + 并行解法）<br>给定一个二维数组 matrix，里面的值不是 1 就是 0，上、下、左、右相邻的 1 认为是一片岛，返回 matrix 中岛的数量</p>
<h1 id="16-图及其与图相关的算法"><a href="#16-图及其与图相关的算法" class="headerlink" title="16 图及其与图相关的算法"></a>16 图及其与图相关的算法</h1><p>内容：</p>
<p>图的表达方式</p>
<p>图的常见描述</p>
<p>图的宽度优先遍历</p>
<p>图的深度优先遍历</p>
<p>图的拓扑排序</p>
<p>最小生成树算法 Kruskal</p>
<p>最小生成树算法 Prim</p>
<p>单元最短路径算法 Dijkstra</p>
<p>题目：</p>
<p>图的数据结构抽象</p>
<p>实现图的宽度优先遍历</p>
<p>实现图的深度优先遍历</p>
<p>三种方式实现图的拓扑排序</p>
<p>用并查集实现 Kruskal 算法</p>
<p>用堆实现 Prim 算法</p>
<p>实现 Dijkstra 算法，用加强堆做更好的实现（16 节+17 节一开始）</p>
<h1 id="17-用加强堆更好的实现-Dijkstra-算法、常见的递归"><a href="#17-用加强堆更好的实现-Dijkstra-算法、常见的递归" class="headerlink" title="17 用加强堆更好的实现 Dijkstra 算法、常见的递归"></a>17 用加强堆更好的实现 Dijkstra 算法、常见的递归</h1><p>内容：</p>
<ol>
<li>加强堆实现 Dijkstra 算法</li>
<li>递归的设计</li>
<li>常见的递归</li>
</ol>
<p>题目：</p>
<ol>
<li>打印 n 层汉诺塔从最左边移动到最右边的全部过程（递归+非递归实现）</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">n: <span class="built_in">int</span>, src: <span class="built_in">str</span>, dst: <span class="built_in">str</span>, other: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;move <span class="subst">&#123;n&#125;</span> from <span class="subst">&#123;src&#125;</span> to <span class="subst">&#123;dst&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        recursion(n-<span class="number">1</span>, src, other, dst)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;move <span class="subst">&#123;n&#125;</span> from <span class="subst">&#123;src&#125;</span> to <span class="subst">&#123;dst&#125;</span>&quot;</span>)</span><br><span class="line">        recursion(n-<span class="number">1</span>, other, dst, src)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">non_recursion</span>(<span class="params">n: <span class="built_in">int</span>, src: <span class="built_in">str</span>, dst: <span class="built_in">str</span>, other: <span class="built_in">str</span></span>):</span><br><span class="line">    stack = []</span><br><span class="line">    stack.append([n, src, dst, other, <span class="literal">False</span>])</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        r = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> r[<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;move <span class="subst">&#123;r[<span class="number">0</span>]&#125;</span> from <span class="subst">&#123;r[<span class="number">1</span>]&#125;</span> to <span class="subst">&#123;r[<span class="number">2</span>]&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> stack:  <span class="comment"># 由于1一定是在最顶上的，如果此时栈非空，则只代表原本1下面的元素可以移动</span></span><br><span class="line">                stack[-<span class="number">1</span>][<span class="number">4</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> r[<span class="number">4</span>]:  <span class="comment"># 该元素当前是否可以移动，即元素上方是否有其他元素</span></span><br><span class="line">                stack.append(r)</span><br><span class="line">                stack.append([r[<span class="number">0</span>]-<span class="number">1</span>, r[<span class="number">1</span>], r[<span class="number">3</span>], r[<span class="number">2</span>], <span class="literal">False</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;move <span class="subst">&#123;r[<span class="number">0</span>]&#125;</span> from <span class="subst">&#123;r[<span class="number">1</span>]&#125;</span> to <span class="subst">&#123;r[<span class="number">2</span>]&#125;</span>&quot;</span>)</span><br><span class="line">                stack.append([r[<span class="number">0</span>]-<span class="number">1</span>, r[<span class="number">3</span>], r[<span class="number">2</span>], r[<span class="number">1</span>], <span class="literal">False</span>])</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>打印一个字符串的全部子序列（可重复+不可重复）</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process1</span>(<span class="params">istr: <span class="built_in">str</span>, idx: <span class="built_in">int</span>, prefix: <span class="built_in">str</span>, res: <span class="built_in">list</span></span>):</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="built_in">len</span>(istr):</span><br><span class="line">        res.append(prefix)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    process1(istr, idx+<span class="number">1</span>, prefix, res)</span><br><span class="line">    process1(istr, idx+<span class="number">1</span>, prefix+istr[idx], res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process2</span>(<span class="params">istr: <span class="built_in">str</span>, idx: <span class="built_in">int</span>, prefix: <span class="built_in">str</span>, res: <span class="built_in">set</span></span>):</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="built_in">len</span>(istr):</span><br><span class="line">        res.add(prefix)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    process2(istr, idx+<span class="number">1</span>, prefix, res)</span><br><span class="line">    process2(istr, idx+<span class="number">1</span>, prefix+istr[idx], res)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>打印一个字符串的全部排列（可重复+不可重复）</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process1</span>(<span class="params">prefix: <span class="built_in">str</span>, istr: <span class="built_in">str</span>, res: <span class="built_in">list</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> istr:</span><br><span class="line">        res.append(prefix)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(istr)):</span><br><span class="line">        s, istr = istr[<span class="number">0</span>], istr[<span class="number">1</span>:]</span><br><span class="line">        process1(prefix+s, istr, res)</span><br><span class="line">        istr += s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process2</span>(<span class="params">prefix: <span class="built_in">str</span>, istr: <span class="built_in">str</span>, res: <span class="built_in">set</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> istr:</span><br><span class="line">        res.add(prefix)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(istr)):</span><br><span class="line">        s, istr = istr[<span class="number">0</span>], istr[<span class="number">1</span>:]</span><br><span class="line">        process2(prefix+s, istr, res)</span><br><span class="line">        istr += s</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>给定一个栈，请逆序这个栈，不能申请额外的数据结构，只能使用递归函数</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_head</span>(<span class="params">stack: <span class="built_in">list</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> stack.pop()</span><br><span class="line">    temp = stack.pop()</span><br><span class="line">    head = get_head(stack)</span><br><span class="line">    stack.append(temp)</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">stack: <span class="built_in">list</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    head = get_head(stack)</span><br><span class="line">    process(stack)</span><br><span class="line">    stack.append(head)</span><br></pre></td></tr></table></figure>

<h1 id="18-暴力递归到动态规划（一）"><a href="#18-暴力递归到动态规划（一）" class="headerlink" title="18 暴力递归到动态规划（一）"></a>18 暴力递归到动态规划（一）</h1><p>内容：</p>
<ol>
<li>讲述暴力递归和动态规划的关系</li>
<li>记忆化搜索</li>
<li>动态规划都可以由暴力递归改进过来，解决动态规划的套路</li>
<li>常见的尝试模型</li>
<li>设计尝试过程的原则</li>
<li>本节是暴力递归到动态规划的总纲（很重要）</li>
<li>后续的课都是在讲述这一系列的套路</li>
</ol>
<p>题目：</p>
<ol>
<li>假设有排成一行的 N 个位置记为 1…N，N 一定大于或等于 2，开始时机器人在其中的 M 位置上(M 一定是 1…N 中的一个)<br>如果机器人来到 1 位置，那么下一步只能往右来到 2 位置；<br>如果机器人来到 N 位置，那么下一步只能往左来到 N-1 位置；<br>如果机器人来到中间位置，那么下一步可以往左走或者往右走；<br>规定机器人必须走 K 步，最终能来到 P 位置(P 也是 1~N 中的一个)的方法有多少种<br>给定四个参数 N、M、K、P，返回方法数</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">border, cur, step, dst</span>):</span><br><span class="line">    <span class="keyword">if</span> step == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> cur != dst <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    ways = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> cur &gt; <span class="number">1</span>:  <span class="comment"># 左</span></span><br><span class="line">        ways += recursion(border, cur-<span class="number">1</span>, step-<span class="number">1</span>, dst)</span><br><span class="line">    <span class="keyword">if</span> cur &lt; border:  <span class="comment"># 右</span></span><br><span class="line">        ways += recursion(border, cur+<span class="number">1</span>, step-<span class="number">1</span>, dst)</span><br><span class="line">    <span class="keyword">return</span> ways</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">border, cur, step, dst</span>):</span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(step+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(border+<span class="number">1</span>)]</span><br><span class="line">    dp[dst][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> rest <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, step+<span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">1</span>][rest] = dp[<span class="number">2</span>][rest-<span class="number">1</span>]</span><br><span class="line">        dp[border][rest] = dp[border-<span class="number">1</span>][rest-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> pos <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, border):</span><br><span class="line">            dp[pos][rest] = dp[pos-<span class="number">1</span>][rest-<span class="number">1</span>] + dp[pos+<span class="number">1</span>][rest-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[cur][step]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>给定一个整型数组 arr，代表数值不同的纸牌排成一条线<br>玩家 A 和玩家 B 依次拿走每张纸牌<br>规定玩家 A 先拿，玩家 B 后拿<br>但是每个玩家每次只能拿走最左或最右的纸牌<br>玩家 A 和玩家 B 都绝顶聪明<br>请返回最后获胜者的分数</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">first</span>(<span class="params">cards: <span class="built_in">list</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cards) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> cards[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 先手拿左的得分+剩下的牌中我后手的得分</span></span><br><span class="line">    p1 = cards[<span class="number">0</span>] + second(cards[<span class="number">1</span>:])</span><br><span class="line">    <span class="comment"># 先手拿右的得分+剩下的牌中我后手的得分</span></span><br><span class="line">    p2 = cards[-<span class="number">1</span>] + second(cards[:-<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 取最大值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(p1, p2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">second</span>(<span class="params">cards: <span class="built_in">list</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cards) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 对面拿走左之后，我在剩下的牌中先手的得分</span></span><br><span class="line">    p1 = first(cards[<span class="number">1</span>:])</span><br><span class="line">    <span class="comment"># 对面拿走右之后，我在剩下的牌中先手的得分</span></span><br><span class="line">    p2 = first(cards[:-<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 取最小值，因为对面会让我在剩下的牌中得分少</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(p1, p2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">cards: <span class="built_in">list</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(first(cards), second(cards))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">first1</span>(<span class="params">cards: <span class="built_in">list</span>, l, r</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> l == r:</span><br><span class="line">        <span class="keyword">return</span> cards[l]</span><br><span class="line">    <span class="comment"># 先手拿左的得分+剩下的牌中我后手的得分</span></span><br><span class="line">    p1 = cards[l] + second1(cards, l+<span class="number">1</span>, r)</span><br><span class="line">    <span class="comment"># 先手拿右的得分+剩下的牌中我后手的得分</span></span><br><span class="line">    p2 = cards[r] + second1(cards, l, r-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 取最大值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(p1, p2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">second1</span>(<span class="params">cards: <span class="built_in">list</span>, l, r</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> l == r:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 对面拿走左之后，我在剩下的牌中先手的得分</span></span><br><span class="line">    p1 = first1(cards, l+<span class="number">1</span>, r)</span><br><span class="line">    <span class="comment"># 对面拿走右之后，我在剩下的牌中先手的得分</span></span><br><span class="line">    p2 = first1(cards, l, r-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 取最小值，因为对面会让我在剩下的牌中得分少</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(p1, p2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">cards: <span class="built_in">list</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    n = <span class="built_in">len</span>(cards)</span><br><span class="line">    dp_f = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    dp_s = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(l, n):</span><br><span class="line">            <span class="keyword">if</span> l == r:</span><br><span class="line">                dp_f[l][r] = cards[l]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp_f[l][r] = <span class="built_in">max</span>(cards[l] + dp_s[l+<span class="number">1</span>][r],</span><br><span class="line">                                 cards[r] + dp_s[l][r-<span class="number">1</span>])</span><br><span class="line">                dp_s[l][r] = <span class="built_in">min</span>(dp_f[l+<span class="number">1</span>][r], dp_f[l][r-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp_f[<span class="number">0</span>][r], dp_s[<span class="number">0</span>][r])</span><br></pre></td></tr></table></figure>

<h1 id="19-暴力递归到动态规划（二）"><a href="#19-暴力递归到动态规划（二）" class="headerlink" title="19 暴力递归到动态规划（二）"></a>19 暴力递归到动态规划（二）</h1><p>内容：</p>
<ol>
<li>以 18 节为总纲</li>
<li>背包问题</li>
<li>记忆化搜索的一个很重要的注意点</li>
<li>通过面试题进一步强化动态规划的解题套路</li>
</ol>
<p>题目：</p>
<ol>
<li>背包问题<br>给定两个长度都为 N 的数组 weights 和 values，weights[i]和 values[i]分别代表 i 号物品的重量和价值<br>给定一个正数 bag，表示一个载重 bag 的袋子，装的物品不能超过这个重量<br>返回能装下的最大价值</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">weights: <span class="built_in">list</span>, values: <span class="built_in">list</span>, idx: <span class="built_in">int</span>, bag: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="built_in">len</span>(weights):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    p1 = process(weights, values, idx+<span class="number">1</span>, bag)</span><br><span class="line">    <span class="keyword">if</span> bag - weights[idx] &gt;= <span class="number">0</span>:</span><br><span class="line">        p2 = values[idx] + process(weights, values, idx+<span class="number">1</span>, bag-weights[idx])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(p1, p2)</span><br><span class="line">    <span class="keyword">return</span> p1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">weights: <span class="built_in">list</span>, values: <span class="built_in">list</span>, bag: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> process(weights, values, <span class="number">0</span>, bag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">weights: <span class="built_in">list</span>, values: <span class="built_in">list</span>, bag: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    n = <span class="built_in">len</span>(weights)</span><br><span class="line">    record = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(bag+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># idx == n -&gt; 0</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> rest <span class="keyword">in</span> <span class="built_in">range</span>(bag+<span class="number">1</span>):</span><br><span class="line">            p1 = record[idx+<span class="number">1</span>][rest]</span><br><span class="line">            <span class="keyword">if</span> rest - weights[idx] &gt;= <span class="number">0</span>:</span><br><span class="line">                p2 = values[idx] + record[idx+<span class="number">1</span>][rest - weights[idx]]</span><br><span class="line">                record[idx][rest] = <span class="built_in">max</span>(p1, p2)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                record[idx][rest] = p1</span><br><span class="line">    <span class="keyword">return</span> record[<span class="number">0</span>][bag]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>规定 1 和 A 对应、2 和 B 对应、3 和 C 对应…26 和 Z 对应<br>那么一个数字字符串比如”111”就可以转化为:<br>“AAA”、”KA”和”AK”<br>给定一个只有数字字符组成的字符串 str，返回有多少种转化结果</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">istr: <span class="built_in">str</span>, idx: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="built_in">len</span>(istr):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> istr[idx] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 要一个</span></span><br><span class="line">    ways = process(istr, idx+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 要两个</span></span><br><span class="line">    <span class="keyword">if</span> idx+<span class="number">1</span> &lt; <span class="built_in">len</span>(istr) <span class="keyword">and</span> <span class="built_in">int</span>(istr[idx:idx+<span class="number">2</span>]) &lt; <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">return</span> ways + process(istr, idx+<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> ways</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">istr: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> process(istr, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">istr: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    record = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(istr)+<span class="number">1</span>)]</span><br><span class="line">    record[-<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(istr)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> istr[idx] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        ways = record[idx+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> idx+<span class="number">1</span> &lt; <span class="built_in">len</span>(istr) <span class="keyword">and</span> <span class="built_in">int</span>(istr[idx:idx+<span class="number">2</span>]) &lt; <span class="number">27</span>:</span><br><span class="line">            record[idx] = ways + record[idx+<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            record[idx] = ways</span><br><span class="line">    <span class="keyword">return</span> record[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>给定一个字符串 str，给定一个字符串类型的数组 arr，出现的字符都是小写英文<br>arr 每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出 str 来<br>返回需要至少多少张贴纸可以完成这个任务<br>例子：str&#x3D; “babac”，arr &#x3D; {“ba”,”c”,”abcd”}<br>ba + ba + c 3 abcd + abcd 2 abcd+ba 2<br>所以返回 2</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">istr: <span class="built_in">str</span>, sticker_counts: <span class="built_in">list</span>, record: <span class="built_in">dict</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> istr <span class="keyword">in</span> record.keys():</span><br><span class="line">        <span class="keyword">return</span> record[istr]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> istr:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    istr_counts = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>)]</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> istr:</span><br><span class="line">        istr_counts[<span class="built_in">ord</span>(s) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 遍历看用哪张贴纸可以去掉最多的字符</span></span><br><span class="line">    res = <span class="number">0xffff</span></span><br><span class="line">    <span class="keyword">for</span> sticker <span class="keyword">in</span> sticker_counts:</span><br><span class="line">        <span class="comment"># 优先考虑确认有效的贴纸(剪枝)</span></span><br><span class="line">        <span class="keyword">if</span> sticker[<span class="built_in">ord</span>(istr[<span class="number">0</span>]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        rest = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">            <span class="keyword">if</span> istr_counts[i] &gt; <span class="number">0</span>:</span><br><span class="line">                rest_num = istr_counts[i] - sticker[i]</span><br><span class="line">                rest += <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) + i) * rest_num</span><br><span class="line">        res = <span class="built_in">min</span>(res, process(rest, sticker_counts, record))</span><br><span class="line">    record[istr] = res + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">istr: <span class="built_in">str</span>, stickers: <span class="built_in">list</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    sticker_counts = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(stickers))]</span><br><span class="line">    <span class="keyword">for</span> idx, sticker <span class="keyword">in</span> <span class="built_in">enumerate</span>(stickers):</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> sticker:</span><br><span class="line">            sticker_counts[idx][<span class="built_in">ord</span>(s) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">    record = &#123;&#125;</span><br><span class="line">    res = process(istr, sticker_counts, record)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> res &gt;= <span class="number">0xffff</span> <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>给定两个字符串 str1 和 str2，<br>返回这两个字符串的最长公共子序列长度<br>比如 ： str1 &#x3D; “a12b3c456d”,str2 &#x3D; “1ef23ghi4j56k”<br>最长公共子序列是“123456”，所以返回长度 6</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">str1: <span class="built_in">str</span>, str2: <span class="built_in">str</span>, i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    p1 = process(str1, str2, i-<span class="number">1</span>, j)</span><br><span class="line">    p2 = process(str1, str2, i, j-<span class="number">1</span>)</span><br><span class="line">    p3 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> str1[i] == str2[j]:</span><br><span class="line">        p3 = process(str1, str2, i-<span class="number">1</span>, j-<span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(p1, p2, p3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">str1: <span class="built_in">str</span>, str2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    record = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str2))] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str1))]</span><br><span class="line">    record[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> <span class="keyword">if</span> str1[<span class="number">0</span>] == str2[<span class="number">0</span>] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(str1)):</span><br><span class="line">        record[i][<span class="number">0</span>] = <span class="built_in">max</span>(record[i-<span class="number">1</span>][<span class="number">0</span>], <span class="number">1</span> <span class="keyword">if</span> str1[i] == str2[<span class="number">0</span>] <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(str2)):</span><br><span class="line">        record[<span class="number">0</span>][j] = <span class="built_in">max</span>(record[<span class="number">0</span>][j-<span class="number">1</span>], <span class="number">1</span> <span class="keyword">if</span> str1[<span class="number">0</span>] == str2[j] <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(str1)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(str2)):</span><br><span class="line">            p1 = record[i-<span class="number">1</span>][j]</span><br><span class="line">            p2 = record[i][j-<span class="number">1</span>]</span><br><span class="line">            p3 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> str1[i] == str2[j]:</span><br><span class="line">                p3 = record[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            record[i][j] = <span class="built_in">max</span>(p1, p2, p3)</span><br><span class="line">    <span class="keyword">return</span> record[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="20-暴力递归到动态规划（三）"><a href="#20-暴力递归到动态规划（三）" class="headerlink" title="20 暴力递归到动态规划（三）"></a>20 暴力递归到动态规划（三）</h1><p>内容：</p>
<ol>
<li>以 18 节为总纲</li>
<li>通过面试题进一步强化动态规划的解题套路</li>
</ol>
<p>题目：</p>
<ol>
<li>给定一个字符串 str，返回这个字符串的最长回文子序列长度<br>比如 ： str &#x3D; “a12b3c43def2ghi1kpm”<br>最长回文子序列是“1234321”或者“123c321”，返回长度 7</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">istr: <span class="built_in">str</span>, l: <span class="built_in">int</span>, r: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> l == r:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> r - l == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> <span class="keyword">if</span> istr[l] == istr[r] <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    p1 = process(istr, l+<span class="number">1</span>, r)</span><br><span class="line">    p2 = process(istr, l, r-<span class="number">1</span>)</span><br><span class="line">    p3 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> istr[l] == istr[r]:</span><br><span class="line">        p3 = process(istr, l+<span class="number">1</span>, r-<span class="number">1</span>) + <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(p1, p2, p3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">istr: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> process(istr, <span class="number">0</span>, <span class="built_in">len</span>(istr) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">istr: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    n = <span class="built_in">len</span>(istr)</span><br><span class="line">    record = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># for i in range(n):</span></span><br><span class="line">    <span class="comment">#     record[i][i] = 1</span></span><br><span class="line">    <span class="comment"># for l in range(n-1):</span></span><br><span class="line">    <span class="comment">#     record[l][l+1] = 2 if istr[l] == istr[l+1] else 1</span></span><br><span class="line">    <span class="comment"># 将两个循环合并</span></span><br><span class="line">    record[-<span class="number">1</span>][-<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">        record[i][i] = <span class="number">1</span></span><br><span class="line">        record[i][i+<span class="number">1</span>] = <span class="number">2</span> <span class="keyword">if</span> istr[i] == istr[i+<span class="number">1</span>] <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">3</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(l+<span class="number">2</span>, n):</span><br><span class="line">            record[l][r] = <span class="built_in">max</span>(record[l+<span class="number">1</span>][r], record[l][r-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> istr[l] == istr[r]:</span><br><span class="line">                record[l][r] = <span class="built_in">max</span>(record[l][r], record[l+<span class="number">1</span>][r-<span class="number">1</span>] + <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> record[<span class="number">0</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>请同学们自行搜索或者想象一个象棋的棋盘，<br>然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置<br>那么整个棋盘就是横坐标上 9 条线、纵坐标上 10 条线的区域<br>给你三个 参数 x，y，k<br>返回“马”从(0,0)位置出发，必须走 k 步<br>最后落在(x,y)上的方法数有多少种?</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">src: <span class="built_in">tuple</span>, dst: <span class="built_in">tuple</span>, step: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> <span class="number">0</span> &lt;= src[<span class="number">0</span>] &lt;= <span class="number">8</span>) <span class="keyword">or</span> (<span class="keyword">not</span> <span class="number">0</span> &lt;= src[<span class="number">1</span>] &lt;= <span class="number">9</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> step == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> src == dst <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 八个方向</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    res += process((src[<span class="number">0</span>]+<span class="number">1</span>, src[<span class="number">1</span>]+<span class="number">2</span>), dst, step-<span class="number">1</span>)</span><br><span class="line">    res += process((src[<span class="number">0</span>]+<span class="number">1</span>, src[<span class="number">1</span>]-<span class="number">2</span>), dst, step-<span class="number">1</span>)</span><br><span class="line">    res += process((src[<span class="number">0</span>]+<span class="number">2</span>, src[<span class="number">1</span>]+<span class="number">1</span>), dst, step-<span class="number">1</span>)</span><br><span class="line">    res += process((src[<span class="number">0</span>]+<span class="number">2</span>, src[<span class="number">1</span>]-<span class="number">1</span>), dst, step-<span class="number">1</span>)</span><br><span class="line">    res += process((src[<span class="number">0</span>]-<span class="number">1</span>, src[<span class="number">1</span>]+<span class="number">2</span>), dst, step-<span class="number">1</span>)</span><br><span class="line">    res += process((src[<span class="number">0</span>]-<span class="number">1</span>, src[<span class="number">1</span>]-<span class="number">2</span>), dst, step-<span class="number">1</span>)</span><br><span class="line">    res += process((src[<span class="number">0</span>]-<span class="number">2</span>, src[<span class="number">1</span>]+<span class="number">1</span>), dst, step-<span class="number">1</span>)</span><br><span class="line">    res += process((src[<span class="number">0</span>]-<span class="number">2</span>, src[<span class="number">1</span>]-<span class="number">1</span>), dst, step-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">dst: <span class="built_in">tuple</span>, step: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> process((<span class="number">0</span>, <span class="number">0</span>), dst, step)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">dst: <span class="built_in">tuple</span>, step: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    record = [[[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">              <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(step+<span class="number">1</span>)]</span><br><span class="line">    record[<span class="number">0</span>][dst[<span class="number">0</span>]][dst[<span class="number">1</span>]] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_valid_value</span>(<span class="params">pos: <span class="built_in">tuple</span>, k: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> <span class="number">0</span> &lt;= pos[<span class="number">0</span>] &lt;= <span class="number">8</span>) <span class="keyword">or</span> (<span class="keyword">not</span> <span class="number">0</span> &lt;= pos[<span class="number">1</span>] &lt;= <span class="number">9</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> record[k][pos[<span class="number">0</span>]][pos[<span class="number">1</span>]]</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, step+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">                res = <span class="number">0</span></span><br><span class="line">                res += get_valid_value((x+<span class="number">1</span>, y+<span class="number">2</span>), k-<span class="number">1</span>)</span><br><span class="line">                res += get_valid_value((x+<span class="number">1</span>, y-<span class="number">2</span>), k-<span class="number">1</span>)</span><br><span class="line">                res += get_valid_value((x+<span class="number">2</span>, y+<span class="number">1</span>), k-<span class="number">1</span>)</span><br><span class="line">                res += get_valid_value((x+<span class="number">2</span>, y-<span class="number">1</span>), k-<span class="number">1</span>)</span><br><span class="line">                res += get_valid_value((x-<span class="number">1</span>, y+<span class="number">2</span>), k-<span class="number">1</span>)</span><br><span class="line">                res += get_valid_value((x-<span class="number">1</span>, y-<span class="number">2</span>), k-<span class="number">1</span>)</span><br><span class="line">                res += get_valid_value((x-<span class="number">2</span>, y+<span class="number">1</span>), k-<span class="number">1</span>)</span><br><span class="line">                res += get_valid_value((x-<span class="number">2</span>, y-<span class="number">1</span>), k-<span class="number">1</span>)</span><br><span class="line">                record[k][x][y] = res</span><br><span class="line">    <span class="keyword">return</span> record[step][<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>给定一个数组 arr，arr[i]代表第 i 号咖啡机泡一杯咖啡的时间<br>给定一个正数 N，表示 N 个人等着咖啡机泡咖啡，每台咖啡机只能轮流泡咖啡<br>只有一台咖啡机，一次只能洗一个杯子，时间耗费 a，洗完才能洗下一杯<br>每个咖啡杯也可以自己挥发干净，时间耗费 b，咖啡杯可以并行挥发<br>假设所有人拿到咖啡之后立刻喝干净，<br>返回从开始等到所有咖啡机变干净的最短时间<br>三个参数：int[] arr、int N，int a、int b</li>
</ol>
<h1 id="21-暴力递归到动态规划（四）"><a href="#21-暴力递归到动态规划（四）" class="headerlink" title="21 暴力递归到动态规划（四）"></a>21 暴力递归到动态规划（四）</h1><p>内容：</p>
<ol>
<li>以 18 节为总纲</li>
<li>通过面试题进一步强化动态规划的解题套路</li>
</ol>
<p>题目：</p>
<ol>
<li>给定一个二维数组 matrix，一个人必须从左上角出发，最后到达右下角<br>沿途只可以向下或者向右走，沿途的数字都累加就是距离累加和<br>返回最小距离累加和</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">matrix: <span class="built_in">list</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    lenx = <span class="built_in">len</span>(matrix)</span><br><span class="line">    leny = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    record = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(leny)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(lenx)]</span><br><span class="line">    record[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, lenx):</span><br><span class="line">        record[i][<span class="number">0</span>] = record[i-<span class="number">1</span>][<span class="number">0</span>] + matrix[i][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, leny):</span><br><span class="line">        record[<span class="number">0</span>][i] = record[<span class="number">0</span>][i-<span class="number">1</span>] + matrix[<span class="number">0</span>][i]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, lenx):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, leny):</span><br><span class="line">            record[x][y] = <span class="built_in">min</span>(record[x][y-<span class="number">1</span>], record[x-<span class="number">1</span>][y]) + matrix[x][y]</span><br><span class="line">    <span class="keyword">return</span> record[lenx-<span class="number">1</span>][leny-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>arr 是货币数组，其中的值都是正数。再给定一个正数 aim。<br>每个值都认为是一张货币，<br>即便是值相同的货币也认为每一张都是不同的，<br>返回组成 aim 的方法数<br>例如：arr &#x3D; {1,1,1}，aim &#x3D; 2<br>第 0 个和第 1 个能组成 2，第 1 个和第 2 个能组成 2，第 0 个和第 2 个能组成 2<br>一共就 3 种方法，所以返回 3</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">arr: <span class="built_in">list</span>, idx: <span class="built_in">int</span>, rest: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> rest &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> idx == <span class="built_in">len</span>(arr):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> rest == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> process(arr, idx+<span class="number">1</span>, rest) + process(arr, idx+<span class="number">1</span>, rest-arr[idx])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">arr: <span class="built_in">list</span>, aim: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> process(arr, <span class="number">0</span>, aim)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">arr: <span class="built_in">list</span>, aim: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    record = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(aim+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)+<span class="number">1</span>)]</span><br><span class="line">    record[-<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> rest <span class="keyword">in</span> <span class="built_in">range</span>(aim+<span class="number">1</span>):</span><br><span class="line">            record[idx][rest] = record[idx+<span class="number">1</span>][rest]</span><br><span class="line">            <span class="keyword">if</span> rest-arr[idx] &gt;= <span class="number">0</span>:</span><br><span class="line">                record[idx][rest] += record[idx+<span class="number">1</span>][rest-arr[idx]]</span><br><span class="line">    <span class="keyword">return</span> record[<span class="number">0</span>][aim]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>arr 是面值数组，其中的值都是正数且没有重复。再给定一个正数 aim。<br>每个值都认为是一种面值，且认为张数是无限的。<br>返回组成 aim 的方法数<br>例如：arr &#x3D; {1,2}，aim &#x3D; 4<br>方法如下：1+1+1+1、1+1+2、2+2<br>一共就 3 种方法，所以返回 3</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">arr: <span class="built_in">list</span>, idx: <span class="built_in">int</span>, rest: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> rest &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> idx == <span class="built_in">len</span>(arr):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> rest == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rest//arr[idx]+<span class="number">1</span>):</span><br><span class="line">        res += process(arr, idx+<span class="number">1</span>, rest-(i*arr[idx]))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">arr: <span class="built_in">list</span>, aim: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> process(arr, <span class="number">0</span>, aim)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">arr: <span class="built_in">list</span>, aim: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    record = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(aim+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)+<span class="number">1</span>)]</span><br><span class="line">    record[-<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> rest <span class="keyword">in</span> <span class="built_in">range</span>(aim+<span class="number">1</span>):</span><br><span class="line">            record[idx][rest] = record[idx+<span class="number">1</span>][rest]</span><br><span class="line">            <span class="keyword">if</span> rest-arr[idx] &gt;= <span class="number">0</span>:</span><br><span class="line">                record[idx][rest] += record[idx][rest - arr[idx]]</span><br><span class="line">    <span class="keyword">return</span> record[<span class="number">0</span>][aim]</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>arr 是货币数组，其中的值都是正数。再给定一个正数 aim。<br>每个值都认为是一张货币，<br>认为值相同的货币没有任何不同，<br>返回组成 aim 的方法数<br>例如：arr &#x3D; {1,2,1,1,2,1,2}，aim &#x3D; 4<br>方法：1+1+1+1、1+1+2、2+2<br>一共就 3 种方法，所以返回 3</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">values: <span class="built_in">list</span>, counts: <span class="built_in">list</span>, idx: <span class="built_in">int</span>, rest: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> rest &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> idx == <span class="built_in">len</span>(values):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> rest == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(counts[idx]+<span class="number">1</span>):</span><br><span class="line">        res += process(values, counts, idx+<span class="number">1</span>, rest-(i*values[idx]))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">arr: <span class="built_in">list</span>, aim: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        data[i] = data[i] + <span class="number">1</span> <span class="keyword">if</span> data.get(i) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> process(<span class="built_in">list</span>(data.keys()), <span class="built_in">list</span>(data.values()), <span class="number">0</span>, aim)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">arr: <span class="built_in">list</span>, aim: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        data[i] = data[i] + <span class="number">1</span> <span class="keyword">if</span> data.get(i) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    values = <span class="built_in">list</span>(data.keys())</span><br><span class="line">    counts = <span class="built_in">list</span>(data.values())</span><br><span class="line">    record = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(aim+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(values)+<span class="number">1</span>)]</span><br><span class="line">    record[-<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(values)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> rest <span class="keyword">in</span> <span class="built_in">range</span>(aim+<span class="number">1</span>):</span><br><span class="line">            record[idx][rest] = record[idx+<span class="number">1</span>][rest]</span><br><span class="line">            <span class="keyword">if</span> rest-values[idx] &gt;= <span class="number">0</span>:</span><br><span class="line">                record[idx][rest] += record[idx][rest-values[idx]]</span><br><span class="line">            <span class="keyword">if</span> rest-(counts[idx]+<span class="number">1</span>)*values[idx] &gt;= <span class="number">0</span>:</span><br><span class="line">                record[idx][rest] -= record[idx+<span class="number">1</span>][rest-(counts[idx]+<span class="number">1</span>)*values[idx]]</span><br><span class="line">    <span class="keyword">return</span> record[<span class="number">0</span>][aim]</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>给定 5 个参数，N，M，row，col，k<br>表示在 N<em>M 的区域上，醉汉 Bob 初始在(row,col)位置 Bob 一共要迈出 k 步，且每步都会等概率向上下左右四个方向走一个单位任何时候 Bob 只要离开 N</em>M 的区域，就直接死亡<br>返回 k 步之后，Bob 还在 N*M 的区域的概率</li>
</ol>
<h1 id="22-暴力递归到动态规划（五）"><a href="#22-暴力递归到动态规划（五）" class="headerlink" title="22 暴力递归到动态规划（五）"></a>22 暴力递归到动态规划（五）</h1><p>内容：</p>
<ol>
<li>以 18 节为总纲</li>
<li>通过面试题进一步强化动态规划的解题套路</li>
<li>斜率优化技巧</li>
</ol>
<p>题目：</p>
<ol>
<li>给定 3 个参数，N，M，K<br>怪兽有 N 滴血，等着英雄来砍自己<br>英雄每一次打击，都会让怪兽流失[0…M]的血量到底流失多少？每一次在[0…M]上等概率的获得一个值<br>求 K 次打击之后，英雄把怪兽砍死的概率</li>
<li>arr 是面值数组，其中的值都是正数且没有重复。再给定一个正数 aim。<br>每个值都认为是一种面值，且认为张数是无限的。<br>返回组成 aim 的最少货币数</li>
<li>给定一个正数 n，求 n 的裂开方法数，<br>规定：后面的数不能比前面的数小<br>比如 4 的裂开方法有：<br>1+1+1+1、1+1+2、1+3、2+2、4<br>5 种，所以返回 5</li>
</ol>
<h1 id="23-暴力递归到动态规划（六）"><a href="#23-暴力递归到动态规划（六）" class="headerlink" title="23 暴力递归到动态规划（六）"></a>23 暴力递归到动态规划（六）</h1><p>内容：</p>
<ol>
<li>以 18 节为总纲</li>
<li>通过面试题进一步强化动态规划的解题套路</li>
<li>位信息技巧</li>
</ol>
<p>题目：</p>
<ol>
<li>给定一个正数数组 arr，<br>请把 arr 中所有的数分成两个集合，尽量让两个集合的累加和接近<br>返回最接近的情况下，较小集合的累加和</li>
<li>给定一个正数数组 arr，请把 arr 中所有的数分成两个集合<br>如果 arr 长度为偶数，两个集合包含数的个数要一样多<br>如果 arr 长度为奇数，两个集合包含数的个数必须只差一个<br>请尽量让两个集合的累加和接近<br>返回最接近的情况下，较小集合的累加和</li>
<li>N 皇后问题是指在 N*N 的棋盘上要摆 N 个皇后，<br>要求任何两个皇后不同行、不同列， 也不在同一条斜线上<br> 给定一个整数 n，返回 n 皇后的摆法有多少种。n&#x3D;1，返回 1<br>n&#x3D;2 或 3，2 皇后和 3 皇后问题无论怎么摆都不行，返回 0<br>n&#x3D;8，返回 92</li>
</ol>
<h1 id="24-窗口内最大值或最小值的更新结构"><a href="#24-窗口内最大值或最小值的更新结构" class="headerlink" title="24 窗口内最大值或最小值的更新结构"></a>24 窗口内最大值或最小值的更新结构</h1><p>内容：</p>
<ol>
<li>滑动窗口</li>
<li>窗口内最大值或最小值的更新结构</li>
<li>用题目来学习窗口内最大值或最小值的更新结构提供的便利性</li>
</ol>
<p>题目：</p>
<ol>
<li>窗口内最大值或最小值更新结构的实现<br>假设一个固定大小为 W 的窗口，依次划过 arr，<br>返回每一次滑出状况的最大值<br>例如，arr &#x3D; [4,3,5,4,3,3,6,7], W &#x3D; 3<br>返回：[5,5,5,4,6,7]</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_max_array</span>(<span class="params">arr: <span class="built_in">list</span>, w: <span class="built_in">int</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> arr <span class="keyword">or</span> w &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) == <span class="number">1</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr) &lt; w:</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">max</span>(arr), ]</span><br><span class="line">    r = <span class="number">0</span></span><br><span class="line">    maxq = []  <span class="comment"># 双端队列</span></span><br><span class="line">    result = []  <span class="comment"># 存放结果</span></span><br><span class="line">    <span class="comment"># 这里窗口两端为闭区间，[r-w+1, r]</span></span><br><span class="line">    <span class="comment"># 先进行移动，判断右侧是否纳入，判断左侧是否移除，然后计结果</span></span><br><span class="line">    <span class="keyword">while</span> r &lt; <span class="built_in">len</span>(arr):</span><br><span class="line">        <span class="keyword">while</span> maxq <span class="keyword">and</span> arr[r] &gt;= arr[maxq[-<span class="number">1</span>]]:</span><br><span class="line">            maxq.pop()</span><br><span class="line">        maxq.append(r)</span><br><span class="line">        <span class="comment"># 队列头部存的索引是否已失效，当前左边界(r-w+1)</span></span><br><span class="line">        <span class="keyword">if</span> maxq[<span class="number">0</span>] &lt; r - w + <span class="number">1</span>:</span><br><span class="line">            maxq.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 窗口宽度(r-0+1)至少要达到 w 才开始统计</span></span><br><span class="line">        <span class="keyword">if</span> r + <span class="number">1</span> &gt;= w:</span><br><span class="line">            result.append(arr[maxq[<span class="number">0</span>]])</span><br><span class="line">        r += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>给定一个整型数组 arr，和一个整数 num<br>某个 arr 中的子数组 sub，如果想达标，必须满足：sub 中最大值 – sub 中最小值 &lt;&#x3D; num，<br>返回 arr 中达标子数组的数量</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果某个区间满足给定条件，则其子区间也满足</span></span><br><span class="line"><span class="comment"># 如果某个区间不满足给定条件，则其父区间也不满足</span></span><br><span class="line"><span class="comment"># 左边固定，右边移动，直到出现不满足的情况，记录满足的区间</span></span><br><span class="line"><span class="comment"># 此时左边移动，并判断是否满足</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">arr: <span class="built_in">list</span>, num: <span class="built_in">int</span></span>):</span><br><span class="line">    maxq = []</span><br><span class="line">    minq = []</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = <span class="number">0</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; <span class="built_in">len</span>(arr):</span><br><span class="line">        <span class="keyword">if</span> r &lt; <span class="built_in">len</span>(arr):</span><br><span class="line">            <span class="keyword">while</span> maxq <span class="keyword">and</span> arr[maxq[-<span class="number">1</span>]] &lt;= arr[r]:</span><br><span class="line">                maxq.pop()</span><br><span class="line">            maxq.append(r)</span><br><span class="line">            <span class="keyword">while</span> minq <span class="keyword">and</span> arr[minq[-<span class="number">1</span>]] &gt;= arr[r]:</span><br><span class="line">                minq.pop()</span><br><span class="line">            minq.append(r)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> arr[maxq[<span class="number">0</span>]] - arr[minq[<span class="number">0</span>]] &lt;= num:</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        result += r-l</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> maxq[<span class="number">0</span>] &lt; l:</span><br><span class="line">            maxq.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> minq[<span class="number">0</span>] &lt; l:</span><br><span class="line">            minq.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>加油站的良好出发点问题</p>
</li>
<li><p>动态规划中利用窗口内最大值或最小值更新结构做优化（难）<br>arr 是货币数组，其中的值都是正数。再给定一个正数 aim。<br>每个值都认为是一张货币，<br>返回组成 aim 的最少货币数<br>注意：因为是求最少货币数，所以每一张货币认为是相同或者不同就不重要了</p>
</li>
</ol>
<h1 id="25-单调栈"><a href="#25-单调栈" class="headerlink" title="25 单调栈"></a>25 单调栈</h1><p>内容：</p>
<ol>
<li><p>单调栈的原理（无重复数+有重复数）</p>
</li>
<li><p>用题目来学习单调栈提供的便利性</p>
</li>
</ol>
<p>题目：</p>
<ol>
<li><p>单调栈实现（无重复数+有重复数）</p>
</li>
<li><p>给定一个只包含正数的数组 arr，arr 中任何一个子数组 sub，<br>一定都可以算出(sub 累加和 )* (sub 中的最小值)是什么，<br>那么所有子数组中，这个值最大是多少？</p>
</li>
<li><p>给定一个非负数组 arr，代表直方图，返回直方图的最大长方形面积</p>
</li>
<li><p>给定一个二维数组 matrix，其中的值不是 0 就是 1，返回全部由 1 组成的最大子矩形内部有多少个 1（面积）</p>
</li>
<li><p>给定一个二维数组 matrix，其中的值不是 0 就是 1，返回全部由 1 组成的子矩形数量</p>
</li>
</ol>
<h1 id="26-单调栈相关的题目（续）、斐波那契数列的矩阵快速幂模型"><a href="#26-单调栈相关的题目（续）、斐波那契数列的矩阵快速幂模型" class="headerlink" title="26 单调栈相关的题目（续）、斐波那契数列的矩阵快速幂模型"></a>26 单调栈相关的题目（续）、斐波那契数列的矩阵快速幂模型</h1><p>内容：</p>
<p>再讲一个单调栈相关的面试题</p>
<p>斐波那契数列的矩阵快速幂模型详解</p>
<p>题目：</p>
<p>给定一个数组 arr，返回所有子数组最小值的累加和</p>
<p>斐波那契数列矩阵乘法方式的实现</p>
<p>台阶方法数问题<br>一个人可以一次往上迈 1 个台阶，也可以迈 2 个台阶，返回迈上 N 级台阶的方法数</p>
<p>奶牛生小牛问题<br>第一年农场有 1 只成熟的母牛 A，往后的每年：<br>1）每一只成熟的母牛都会生一只母牛<br>2）每一只新出生的母牛都在出生的第三年成熟<br>3）每一只母牛永远不会死<br>返回 N 年后牛的数量</p>
<p>给定一个数 N，想象只由 0 和 1 两种字符，组成的所有长度为 N 的字符串<br>如果某个字符串，任何 0 字符的左边都有 1 紧挨着，认为这个字符串达标<br>返回有多少达标的字符串</p>
<p>用 1<em>2 的瓷砖，把 N</em>2 的区域填满，返回铺瓷砖的方法数</p>
<p>27 KMP 算法</p>
<p>内容：</p>
<p>KMP 算法</p>
<p>和 KMP 算法相关的面试题</p>
<p>题目：</p>
<p>KMP 算法实现</p>
<p>给定两棵二叉树的头节点 head1 和 head2，返回 head1 中是否有某个子树的结构和 head2 完全一样</p>
<p>判断 str1 和 str2 是否互为旋转字符串</p>
<p>28 Manacher 算法</p>
<p>内容：</p>
<p>Manacher 算法</p>
<p>和 Manacher 算法相关的面试题</p>
<p>题目：</p>
<p>Manacher 算法实现</p>
<p>给定一个字符串 str，只能在 str 的后面添加字符，想让 str 整体变成回文串，返回至少要添加几个字符</p>
<p>29 在无序数组中找到第 K 小的数、蓄水池算法</p>
<p>内容：</p>
<p>时间复杂度 O(N)可以解决在无序数组中找到第 K 小的数，这个经典的面试题</p>
<p>改写快排的 partition 方法</p>
<p>bfprt 算法</p>
<p>蓄水池算法</p>
<p>题目：</p>
<p>在无序数组中找到第 K 小的数（改写快排+bfprt）</p>
<p>设计在无序数组中收集最大的前 K 个数字的算法（根据不同的三个时间复杂度，设计三个算法）<br>给定一个无序数组 arr 中，长度为 N，给定一个正数 k，返回 top k 个最大的数<br>不同时间复杂度三个方法：<br>1）O(N<em>logN)2）O(N + K</em>logN)<br>3）O(n + k*logk)</p>
<p>蓄水池算法实现<br>假设有一个源源吐出不同球的机器，<br>只有装下 10 个球的袋子，每一个吐出的球，要么放入袋子，要么永远扔掉<br>如何做到机器吐出每一个球之后，所有吐出的球都等概率被放进袋子里</p>
<p>30 二叉树的 Morris 遍历</p>
<p>内容：</p>
<p>二叉树之前的遍历方式有空间浪费的问题</p>
<p>Morris 遍历时间复杂度 O(N)，额外空间复杂度 O(1)，通过利用原树中大量空闲指针的方式，达到节省空间的目的</p>
<p>假设来到当前节点 cur，开始时 cur 来到头节点位置<br>1）如果 cur 没有左孩子，cur 向右移动(cur &#x3D; cur.right)<br>2）如果 cur 有左孩子，找到左子树上最右的节点 mostRight：<br> a.如果 mostRight 的右指针指向空，让其指向 cur，<br> 然后 cur 向左移动(cur &#x3D; cur.left)<br> b.如果 mostRight 的右指针指向 cur，让其指向 null，<br> 然后 cur 向右移动(cur &#x3D; cur.right)<br>3）cur 为空时遍历停止</p>
<p>Morris 遍历实现二叉树的先序、中序、后序遍历</p>
<p>题目：</p>
<p>Morris 遍历的实现</p>
<p>给定一棵二叉树的头节点 head，求以 head 为头的树中，最小深度是多少？</p>
<p>31 线段树</p>
<p>内容：</p>
<p>线段树是一种支持范围整体修改和范围整体查询的数据结构</p>
<p>线段树解决的问题范畴：大范围信息可以只由左、右两侧信息加工出，而不必遍历左右两个子范围的具体状况</p>
<p>题目：</p>
<p>给定一个数组 arr，用户希望你实现如下三个方法<br>1）void add(int L, int R, int V) : 让数组 arr[L…R]上每个数都加上 V<br>2）void update(int L, int R, int V) : 让数组 arr[L…R]上每个数都变成 V<br>3）int sum(int L, int R) :让返回 arr[L…R]这个范围整体的累加和<br>怎么让这三个方法，时间复杂度都是 O(logN)</p>
<p>想象一下标准的俄罗斯方块游戏，X 轴是积木最终下落到底的轴线<br>下面是这个游戏的简化版：<br>1）只会下落正方形积木<br>2）[a,b] -&gt; 代表一个边长为 b 的正方形积木，积木左边缘沿着 X &#x3D; a 这条线从上方掉落<br>3）认为整个 X 轴都可能接住积木，也就是说简化版游戏是没有整体的左右边界的<br>4）没有整体的左右边界，所以简化版游戏不会消除积木，因为不会有哪一层被填满。<br>给定一个 N*2 的二维数组 matrix，可以代表 N 个积木依次掉落，<br>返回每一次掉落之后的最大高度<br>Leetcode 题目：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/falling-squares/">https://leetcode.com/problems/falling-squares/</a></p>
<p>32 IndexTree、AC 自动机</p>
<p>内容：</p>
<p>IndexTree<br>1）支持区间查询<br>2）没有线段树那么强，但是非常容易改成一维、二维、三维的结构<br>3）只支持单点更新</p>
<p>AC 自动机<br>解决在一个大字符串中，找到多个候选字符串的问题<br>1）把所有匹配串生成一棵前缀树<br>2）前缀树节点增加 fail 指针<br>3）fail 指针的含义：如果必须以当前字符结尾，当前形成的路径是 str，剩下哪一个字符串的前缀和 str 的后缀<br> 拥有最大的匹配长度。fail 指针就指向那个字符串的最后一个字符所对应的节点（迷不迷？听讲述！）</p>
<p>题目：</p>
<p>IndexTree 在一维数组和二维数组上的实现</p>
<p>AC 自动机的实现</p>
<p>33 与哈希函数有关的结构</p>
<p>内容：</p>
<p>哈希函数</p>
<p>哈希函数的应用</p>
<p>布隆过滤器</p>
<p>一致性哈希</p>
<p>题目：</p>
<p>原理讲述为主，面试只会聊设计，所以本节无题目</p>
<p>34 资源限制类题目的解题套路</p>
<p>内容：</p>
<p>布隆过滤器用于集合的建立与查询，并可以节省大量空间<br>一致性哈希解决数据服务器的负载管理问题<br>利用并查集结构做岛问题的并行计算<br>哈希函数可以把数据按照种类均匀分流<br>位图解决某一范围上数字的出现情况，并可以节省大量空间<br>利用分段统计思想、并进一步节省大量空间<br>利用堆、外排序来做多个处理单元的结果合并</p>
<p>题目：</p>
<p>32 位无符号整数的范围是 0~4,294,967,295，<br>现在有一个正好包含 40 亿个无符号整数的文件，<br>可以使用最多 1GB 的内存，怎么找到出现次数最多的数？</p>
<p>32 位无符号整数的范围是 0~4,294,967,295，现在有一个正好包含 40 亿个无符号整数的文件，<br>所以在整个范围中必然存在没出现过的数，可以使用最多 1GB 的内存，怎么找到所有未出现过的数？<br>进阶：内存限制为 3KB，但是只用找到一个没出现过的数即可</p>
<p>有一个包含 100 亿个 URL 的大文件，假设每个 URL 占用 64B，请找出其中所有重复的 URL<br>补充：某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，请设计一种求出每天热门 Top100 词汇的可行办法</p>
<p>32 位无符号整数的范围是 0~4294967295，现在有 40 亿个无符号整数，可以使用最多 1GB 的内存，找出所有出现了两次的数</p>
<p>32 位无符号整数的范围是 0~4294967295，现在有 40 亿个无符号整数，可以使用最多 3K 的内存，怎么找到这 40 亿个整数的中位数？</p>
<p>32 位无符号整数的范围是 0~4294967295，有一个 10G 大小的文件，每一行都装着这种类型的数字，<br>整个文件是无序的，给你 5G 的内存空间，请你输出一个 10G 大小的文件，就是原文件所有数字排序的结果</p>
<p>35 有序表（上）</p>
<p>内容：</p>
<p>平衡搜索二叉树</p>
<p>左旋</p>
<p>右旋</p>
<p>AVL 树的节点违规 4 种类型（LL，LR，RL，RR）</p>
<p>题目：</p>
<p>AVL 树的实现</p>
<p>36 有序表（中）</p>
<p>内容：</p>
<p>size-balanced-tree 详解</p>
<p>skiplist 详解</p>
<p>聊聊红黑树</p>
<p>题目：</p>
<p>size-balanced-tree 实现</p>
<p>skiplist 实现</p>
<p>37 有序表（下）</p>
<p>内容：</p>
<p>讲解有序表相关的面试题</p>
<p>讲解改写有序表的题目核心点</p>
<p>题目：</p>
<p>给定一个数组 arr，和两个整数 a 和 b（a&lt;&#x3D;b）。求 arr 中有多少个子数组，累加和在[a,b]这个范围上。返回达标的子数组数量</p>
<p>有一个滑动窗口：<br>1）L 是滑动窗口最左位置、R 是滑动窗口最右位置，一开始 LR 都在数组左侧<br>2）任何一步都可能 R 往右动，表示某个数进了窗口<br>3）任何一步都可能 L 往右动，表示某个数出了窗口<br>想知道每一个窗口状态的中位数</p>
<p>设计一个结构包含如下两个方法：<br>void add(int index, int num)：把 num 加入到 index 位置<br>int get(int index) ：取出 index 位置的值<br>void remove(int index) ：把 index 位置上的值删除<br>要求三个方法时间复杂度 O(logN)</p>
<p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）<br>每个 people[i]&#x3D;[hi, ki]表示第 i 个人的身高为 hi，前面正好有 ki 个身高大于或等于 hi 的人<br>请你重新构造并返回输入数组 people 所表示的队列，返回的队列应该格式化为数组 queue<br>其中 queue[j]&#x3D;[hj, kj]是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。<br>Leetcode 题目：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/queue-reconstruction-by-height/">https://leetcode.com/problems/queue-reconstruction-by-height/</a></p>
<p>38 根据对数器找规律、根据数据量猜解法</p>
<p>内容：</p>
<p>讲解对数器找规律的解题技巧</p>
<p>讲解根据数据量猜解法的技巧<br>1）C&#x2F;C++，1 秒处理的指令条数为 10 的 8 次方<br>2）Java 等语言，1~4 秒处理的指令条数为 10 的 8 次方<br>3）这里就有大量的分析提示了</p>
<p>题目：</p>
<p>小虎去买苹果，商店只提供两种类型的塑料袋，每种类型都有任意数量<br>1）能装下 6 个苹果的袋子<br>2）能装下 8 个苹果的袋子<br>小虎可以自由使用两种袋子来装苹果，但是小虎有强迫症，他要求自己使用的袋子数量必须最少，<br>且使用的每个袋子必须装满，给定一个正整数 N，返回至少使用多少袋子。如果 N 无法让使用的每个袋子必须装满，返回-1</p>
<p>给定一个正整数 N，表示有 N 份青草统一堆放在仓库里，有一只牛和一只羊，牛先吃，羊后吃，它俩轮流吃草<br>不管是牛还是羊，每一轮能吃的草量必须是：1，4，16，64…(4 的某次方)<br>谁最先把草吃完，谁获胜，假设牛和羊都绝顶聪明，都想赢，都会做出理性的决定。根据唯一的参数 N，返回谁会赢</p>
<p>定义一种数：可以表示成若干（数量&gt;1）连续正数和的数<br>比如，5&#x3D;2+3，5 就是这样的数；12&#x3D;3+4+5，12 就是这样的数<br>2&#x3D;1+1，2 不是这样的数，因为等号右边不是连续正数<br>给定一个参数 N，返回是不是可以表示成若干连续正数和的数</p>
<p>int[] d，d[i]：i 号怪兽的能力<br>int[] p，p[i]：i 号怪兽要求的钱<br>开始时你的能力是 0，你的目标是从 0 号怪兽开始，通过所有的怪兽。<br>如果你当前的能力，小于 i 号怪兽的能力，你必须付出 p[i]的钱，贿赂这个怪兽，然后怪兽就会加入你<br>他的能力直接累加到你的能力上；如果你当前的能力，大于等于 i 号怪兽的能力<br>你可以选择直接通过，你的能力并不会下降，你也可以选择贿赂这个怪兽，然后怪兽就会加入你<br>他的能力直接累加到你的能力上<br>返回通过所有的怪兽，需要花的最小钱数<br>（课上会给出不同的数据量描述）</p>
<p>39 根据数据量猜解法（续）、分治技巧、卡特兰数</p>
<p>内容：</p>
<p>继续熟悉根据数据量猜解法</p>
<p>讲解分治法</p>
<p>讲解卡特兰数（课上证明的时候有小错，在 40 节开始处修正了）</p>
<p>题目：</p>
<p>给定一个非负数组 arr，和一个正数 m，返回 arr 的所有子序列中累加和%m 之后的最大值</p>
<p>牛牛家里一共有 n 袋零食, 第 i 袋零食体积为 v[i]，背包容量为 w，牛牛想知道在总体积不超过背包容量的情况下,<br>一共有多少种零食放法，体积为 0 也算一种放法<br>1 &lt;&#x3D; n &lt;&#x3D; 30, 1 &lt;&#x3D; w &lt;&#x3D; 2 * 10^9，v[I] (0 &lt;&#x3D; v[i] &lt;&#x3D; 10^9）</p>
<p>假设给你 N 个 0，和 N 个 1，你必须用全部数字拼序列，返回有多少个序列满足任何前缀串，1 的数量都不少于 0 的数量</p>
<p>有 N 个二叉树节点，每个节点彼此之间无任何差别，返回由 N 个二叉树节点，组成的不同结构数量是多少？</p>
<p>题目补充： arr 中的值可能为正，可能为负，可能为 0，自由选择 arr 中的数字，能不能累加得到 sum（多种做法）</p>
<p>40 子数组达到规定累加和的最大长度系列问题、矩阵处理技巧题</p>
<p>内容：</p>
<p>修正了 39 节卡特兰数讲解时的一个小错误</p>
<p>熟悉子数组达到规定累加和的三个模型（正、有正有负有 0、累加和&lt;&#x3D;K）</p>
<p>矩阵处理技巧的宏观调度 coding 技巧</p>
<p>题目：</p>
<p>给定一个正整数组成的无序数组 arr，给定一个正整数值 K，找到 arr 的所有子数组里，哪个子数组的累加和等于 K<br>并且是长度最大的，返回其长度</p>
<p>给定一个整数组成的无序数组 arr，值可能正、可能负、可能 0，给定一个整数值 K<br>找到 arr 的所有子数组里，哪个子数组的累加和等于 K，并且是长度最大的，返回其长度</p>
<p>给定一个整数组成的无序数组 arr，值可能正、可能负、可能 0，给定一个整数值 K<br>找到 arr 的所有子数组里，哪个子数组的累加和&lt;&#x3D;K，并且是长度最大的，返回其长度</p>
<p>给定一个数组 arr，给定一个值 v，求子数组平均值小于等于 v 的最长子数组长度</p>
<p>给定一个正方形矩阵 matrix，原地调整成顺时针 90 度转动的样子</p>
<p>给定一个正方形或者长方形矩阵 matrix，实现转圈打印</p>
<p>给定一个正方形或者长方形矩阵 matrix，实现 zigzag 打印</p>
<p>转圈打印星号*问题</p>
<p>41 四边形不等式技巧（上）</p>
<p>内容：</p>
<p>区间划分问题中的划分点不回退现象</p>
<p>四边形不等式技巧特征<br>1，两个可变参数的区间划分问题<br>2，每个格子有枚举行为<br>3，当两个可变参数固定一个，另一个参数和答案之间存在单调性关系<br>4，而且两组单调关系是反向的：(升 升，降 降) (升 降，降 升)<br>5，能否获得指导枚举优化的位置对：上+右，或者，左+下</p>
<p>四边形不等式技巧注意点<br>1，不要证明！用对数器验证！<br>2，枚举的时候面对最优答案相等的时候怎么处理？用对数器都试试！<br>3，可以把时间复杂度降低一阶<br>O(N^3) -&gt; O(N^2)<br>O(N^2 _ M) -&gt; O(N _ M)O(N _ M^2) -&gt; O(N _ M)<br>4，四边形不等式有些时候是最优解，有些时候不是<br>不是的原因：尝试思路，在根儿上不够好</p>
<p>题目：</p>
<p>给定一个非负数组 arr，长度为 N，<br>那么有 N-1 种方案可以把 arr 切成左右两部分<br>每一种方案都有，min{左部分累加和，右部分累加和}<br>求这么多方案中，min{左部分累加和，右部分累加和}的最大值是多少？<br>整个过程要求时间复杂度 O(N)</p>
<p>把题目一中提到的，min{左部分累加和，右部分累加和}，定义为 S(N-1)，也就是说：<br>S(N-1)：在 arr[0…N-1]范围上，做最优划分所得到的 min{左部分累加和，右部分累加和}的最大值<br>现在要求返回一个长度为 N 的 s 数组，<br>s[i] &#x3D;在 arr[0…i]范围上，做最优划分所得到的 min{左部分累加和，右部分累加和}的最大值<br>得到整个 s 数组的过程，做到时间复杂度 O(N)</p>
<p>摆放着 n 堆石子。现要将石子有次序地合并成一堆，规定每次只能选相邻的 2 堆石子合并成新的一堆<br>并将新的一堆石子数记为该次合并的得分，求出将 n 堆石子合并成一堆的最小得分（或最大得分）合并方案</p>
<p>给定一个整型数组 arr，数组中的每个值都为正数，表示完成一幅画作需要的时间，再给定一个整数 num<br>表示画匠的数量，每个画匠只能画连在一起的画作<br>所有的画家并行工作，返回完成所有的画作需要的最少时间<br>arr&#x3D;[3,1,4]，num&#x3D;2。<br>最好的分配方式为第一个画匠画 3 和 1，所需时间为 4<br>第二个画匠画 4，所需时间为 4<br>所以返回 4<br>arr&#x3D;[1,1,1,4,3]，num&#x3D;3<br>最好的分配方式为第一个画匠画前三个 1，所需时间为 3<br>第二个画匠画 4，所需时间为 4<br>第三个画匠画 3，所需时间为 3<br>返回 4</p>
<p>42 四边形不等式技巧（下）</p>
<p>内容：</p>
<p>继续熟悉四边形不等式</p>
<p>展示好的尝试是最关键的</p>
<p>题目：</p>
<p>一条直线上有居民点，邮局只能建在居民点上<br>给定一个有序正数数组 arr，每个值表示 居民点的一维坐标，再给定一个正数 num，表示邮局数量<br>选择 num 个居民点建立 num 个邮局，使所有的居民点到最近邮局的总距离最短，返回最短的总距离<br>arr&#x3D;[1,2,3,4,5,1000]，num&#x3D;2<br>第一个邮局建立在 3 位置，第二个邮局建立在 1000 位置<br>那么 1 位置到邮局的距离为 2，2 位置到邮局距离为 1，3 位置到邮局的距离为 0，4 位置到邮局的距离为 1，5 位置到邮局的距离为 2<br>1000 位置到邮局的距离为 0<br>这种方案下的总距离为 6，其他任何方案的总距离都不会比该方案的总距离更短，所以返回 6</p>
<p>一座大楼有 0<del>N 层，地面算作第 0 层，最高的一层为第 N 层已知棋子从第 0 层掉落肯定不会摔碎，从第 i 层掉落可能会摔碎，也可能不会摔碎(1≤i≤N)给定整数 N 作为楼层数，再给定整数 K 作为棋子数返回如果想找到棋子不会摔碎的最高层数，即使在最差的情况下扔的最少次数一次只能扔一个棋子 N&#x3D;10，K&#x3D;1 返回 10 因为只有 1 棵棋子，所以不得不从第 1 层开始一直试到第 10 层在最差的情况下，即第 10 层是不会摔坏的最高层，最少也要扔 10 次 N&#x3D;3，K&#x3D;2 返回 2 先在 2 层扔 1 棵棋子，如果碎了试第 1 层，如果没碎试第 3 层 N&#x3D;105，K&#x3D;2 返回 14 第一个棋子先在 14 层扔，碎了则用仅存的一个棋子试 1</del>13<br>若没碎，第一个棋子继续在 27 层扔，碎了则用仅存的一个棋子试 15<del>26 若没碎，第一个棋子继续在 39 层扔，碎了则用仅存的一个棋子试 28</del>38<br>若没碎，第一个棋子继续在 50 层扔，碎了则用仅存的一个棋子试 40<del>49 若没碎，第一个棋子继续在 60 层扔，碎了则用仅存的一个棋子试 51</del>59<br>若没碎，第一个棋子继续在 69 层扔，碎了则用仅存的一个棋子试 61<del>68 若没碎，第一个棋子继续在 77 层扔，碎了则用仅存的一个棋子试 70</del>76<br>若没碎，第一个棋子继续在 84 层扔，碎了则用仅存的一个棋子试 78<del>83 若没碎，第一个棋子继续在 90 层扔，碎了则用仅存的一个棋子试 85</del>89<br>若没碎，第一个棋子继续在 95 层扔，碎了则用仅存的一个棋子试 91<del>94 若没碎，第一个棋子继续在 99 层扔，碎了则用仅存的一个棋子试 96</del>98<br>若没碎，第一个棋子继续在 102 层扔，碎了则用仅存的一个棋子试 100、101<br>若没碎，第一个棋子继续在 104 层扔，碎了则用仅存的一个棋子试 103<br>若没碎，第一个棋子继续在 105 层扔，若到这一步还没碎，那么 105 便是结果</p>
<p>43 状态压缩的动态规划</p>
<p>内容：</p>
<p>动态规划的状态压缩技巧</p>
<p>题目：</p>
<p>在”100 game”这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和<br>先使得累计整数和达到或超过 100 的玩家，即为胜者，如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？<br>例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;&#x3D; 100<br>给定一个整数 maxChoosableInteger （整数池中可选择的最大数）和另一个整数 desiredTotal（累计和）<br>判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）<br>你可以假设 maxChoosableInteger 不会大于 20， desiredTotal 不会大于 300。<br>Leetcode 题目：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/can-i-win/">https://leetcode.com/problems/can-i-win/</a></p>
<p>TSP 问题<br>有 N 个城市，任何两个城市之间的都有距离，任何一座城市到自己的距离都为 0<br>所有点到点的距离都存在一个 N*N 的二维数组 matrix 里，也就是整张图由邻接矩阵表示<br>现要求一旅行商从 k 城市出发必须经过每一个城市且只在一个城市逗留一次，最后回到出发的 k 城<br>参数给定一个 matrix，给定 k。返回总距离最短的路的距离</p>
<p>铺砖问题（最优解其实是轮廓线 dp，但是这个解法对大厂刷题来说比较难，掌握课上的解法即可）<br>你有无限的 1<em>2 的砖块，要铺满 M</em>N 的区域，<br>不同的铺法有多少种?</p>
<p>44 DC3 生成后缀数组详解</p>
<p>内容：</p>
<p>后缀数组</p>
<p>介绍用 DC3 算法生成后缀数组的流程</p>
<p>题目：</p>
<p>给你一个字符串 s，找出它的所有子串并按字典序排列，返回排在最后的那个子串<br>Leetcode 题目：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/last-substring-in-lexicographical-order/">https://leetcode.com/problems/last-substring-in-lexicographical-order/</a></p>
<p>DC3 算法的实现（完全根据论文描述）</p>
<p>45 后缀数组解决的面试题</p>
<p>内容：</p>
<p>通过题目进一步熟悉 DC3 算法</p>
<p>通过 DC3 算法得到 height 数组</p>
<p>题目：</p>
<p>给定两个字符串 str1 和 str2，想把 str2 整体插入到 str1 中的某个位置，形成最大的字典序，返回字典序最大的结果</p>
<p>给两个长度分别为 M 和 N 的整型数组 nums1 和 nums2，其中每个值都不大于 9，再给定一个正数 K。 你可以在 nums1 和 nums2 中挑选数字，要求一共挑选 K 个，并且要从左到右挑。返回所有可能的结果中，代表最大数字的结果</p>
<p>最长公共子串问题是面试常见题目之一，假设 str1 长度 N，str2 长度 M<br>一般在面试场上回答出 O(N<em>M)的解法已经是比较优秀了因为得到 O(N</em>M)的解法，就已经需要用到动态规划了<br>但其实这个问题的最优解是 O(N+M)，需要用到后缀数组+height 数组<br>课上将对本题解法代码进行详解</p>
<p>46 动态规划猜法中和外部信息简化的相关问题（上）、哈夫曼树</p>
<p>内容：</p>
<p>以 18 节做总纲</p>
<p>有些动态规划面试题，需要很好的设计参数，这种设计方式都有”外部信息简化”的特征</p>
<p>哈夫曼树</p>
<p>题目：</p>
<p>有 n 个气球，编号为 0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中<br>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] _ nums[i] _ nums[i + 1] 枚硬币<br>这里的 i-1 和 i+1 代表和 i 相邻的、没有被戳爆的！两个气球的序号<br>如果 i-1 或 i+1 超出了数组的边界，那么就当它是一个数字为 1 的气球<br>求所能获得硬币的最大数量<br>Leetcode 题目：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/burst-balloons/">https://leetcode.com/problems/burst-balloons/</a></p>
<p>给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色，你将经过若干轮操作去去掉盒子<br>直到所有的盒子都去掉为止，每一轮你可以移除具有相同颜色的连续 k 个盒子（k &gt;&#x3D; 1）<br>这样一轮之后你将得到 k * k 个积分，当你将所有盒子都去掉之后，求你能获得的最大积分和<br>Leetcode 题目：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-boxes/">https://leetcode.com/problems/remove-boxes/</a></p>
<p>如果一个字符相邻的位置没有相同字符，那么这个位置的字符出现不能被消掉<br>比如:”ab”，其中 a 和 b 都不能被消掉<br>如果一个字符相邻的位置有相同字符，就可以一起消掉<br>比如:”abbbc”，中间一串的 b 是可以被消掉的，消除之后剩下”ac”<br>某些字符如果消掉了，剩下的字符认为重新靠在一起<br>给定一个字符串，你可以决定每一步消除的顺序，目标是请尽可能多的消掉字符，返回最少的剩余字符数量<br>比如：”aacca”, 如果先消掉最左侧的”aa”，那么将剩下”cca”，然后把”cc”消掉，剩下的”a”将无法再消除，返回 1<br>但是如果先消掉中间的”cc”，那么将剩下”aaa”，最后都消掉就一个字符也不剩了，返回 0，这才是最优解。<br>再比如：”baaccabb”，<br>如果先消除最左侧的两个 a，剩下”bccabb”，如果再消除最左侧的两个 c，剩下”babb”，最后消除最右侧的两个 b，剩下”ba”无法再消除，返回 2<br>而最优策略是：<br>如果先消除中间的两个 c，剩下”baaabb”，如果再消除中间的三个 a，剩下”bbb”，最后消除三个 b，不留下任何字符，返回 0，这才是最优解</p>
<p>给定一个数组 arr，和一个正数 M，返回在 arr 的子数组在长度不超过 M 的情况下，最大的累加和</p>
<p>哈夫曼树的实现</p>
<p>47 动态规划猜法中和外部信息简化的相关问题（下）、最大网络流算法之 Dinic 算法</p>
<p>内容：</p>
<p>进一步解决带有”外部信息简化”特征的动态规划</p>
<p>Dinic 算法</p>
<p>题目：</p>
<p>有台奇怪的打印机有以下两个特殊要求：<br>打印机每次只能打印由同一个字符组成的序列。<br>每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。<br>给你一个字符串 s，你的任务是计算这个打印机打印它需要的最少打印次数。<br>Leetcode 题目：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/strange-printer/">https://leetcode.com/problems/strange-printer/</a></p>
<p>整型数组 arr 长度为 n(3 &lt;&#x3D; n &lt;&#x3D; 10^4)，最初每个数字是&lt;&#x3D;200 的正数且满足如下条件：</p>
<ol>
<li>0 位置的要求：arr[0]&lt;&#x3D;arr[1]</li>
<li>n-1 位置的要求：arr[n-1]&lt;&#x3D;arr[n-2]</li>
<li>中间 i 位置的要求：arr[i]&lt;&#x3D;max(arr[i-1],arr[i+1])<br>但是在 arr 有些数字丢失了，比如 k 位置的数字之前是正数，丢失之后 k 位置的数字为 0<br>请你根据上述条件，计算可能有多少种不同的 arr 可以满足以上条件<br>比如 [6,0,9] 只有还原成 [6,9,9]满足全部三个条件，所以返回 1，即[6,9,9]达标</li>
</ol>
<p>Dinic 算法详解<br>测试链接：<a target="_blank" rel="noopener" href="https://lightoj.com/problem/internet-bandwidth">https://lightoj.com/problem/internet-bandwidth</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>算法基础</p><p><a href="https://aikenzh.github.io/2023/03/06/算法基础/">https://aikenzh.github.io/2023/03/06/算法基础/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>AikenZh</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-03-06</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-03-24</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Algorithm/">Algorithm</a><a class="link-muted mr-2" rel="tag" href="/tags/python/">python</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/03/06/hello-world/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Hello World</span></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#时间复杂度、空间复杂度"><span class="level-left"><span class="level-item">1</span><span class="level-item">时间复杂度、空间复杂度</span></span></a></li><li><a class="level is-mobile" href="#选择排序"><span class="level-left"><span class="level-item">2</span><span class="level-item">选择排序</span></span></a></li><li><a class="level is-mobile" href="#冒泡排序"><span class="level-left"><span class="level-item">3</span><span class="level-item">冒泡排序</span></span></a></li><li><a class="level is-mobile" href="#插入排序"><span class="level-left"><span class="level-item">4</span><span class="level-item">插入排序</span></span></a></li><li><a class="level is-mobile" href="#二分查找"><span class="level-left"><span class="level-item">5</span><span class="level-item">二分查找</span></span></a></li><li><a class="level is-mobile" href="#异或运算"><span class="level-left"><span class="level-item">6</span><span class="level-item">异或运算</span></span></a></li><li><a class="level is-mobile" href="#03-单双链表、栈和队列、递归和-Master-公式、哈希表和有序表的使用和性能"><span class="level-left"><span class="level-item">7</span><span class="level-item">03 单双链表、栈和队列、递归和 Master 公式、哈希表和有序表的使用和性能</span></span></a></li><li><a class="level is-mobile" href="#04-归并排序及其常见面试题"><span class="level-left"><span class="level-item">8</span><span class="level-item">04 归并排序及其常见面试题</span></span></a></li><li><a class="level is-mobile" href="#05-归并排序面试题-续-、快速排序"><span class="level-left"><span class="level-item">9</span><span class="level-item">05 归并排序面试题(续)、快速排序</span></span></a></li><li><a class="level is-mobile" href="#06-比较器、堆结构、堆排序"><span class="level-left"><span class="level-item">10</span><span class="level-item">06 比较器、堆结构、堆排序</span></span></a></li><li><a class="level is-mobile" href="#07-和堆有关的面试题、加强堆结构"><span class="level-left"><span class="level-item">11</span><span class="level-item">07 和堆有关的面试题、加强堆结构</span></span></a></li><li><a class="level is-mobile" href="#08-前缀树、不基于比较的排序（计数排序、基数排序）、排序算法的稳定性"><span class="level-left"><span class="level-item">12</span><span class="level-item">08 前缀树、不基于比较的排序（计数排序、基数排序）、排序算法的稳定性</span></span></a></li><li><a class="level is-mobile" href="#09-排序算法大总结、链表及其相关面试题"><span class="level-left"><span class="level-item">13</span><span class="level-item">09 排序算法大总结、链表及其相关面试题</span></span></a></li><li><a class="level is-mobile" href="#10-链表相关面试题（续）、二叉树的常见遍历"><span class="level-left"><span class="level-item">14</span><span class="level-item">10 链表相关面试题（续）、二叉树的常见遍历</span></span></a></li><li><a class="level is-mobile" href="#11-二叉树常见面试题和二叉树的递归套路（上）"><span class="level-left"><span class="level-item">15</span><span class="level-item">11 二叉树常见面试题和二叉树的递归套路（上）</span></span></a></li><li><a class="level is-mobile" href="#12-二叉树常见面试题和二叉树的递归套路（中）"><span class="level-left"><span class="level-item">16</span><span class="level-item">12 二叉树常见面试题和二叉树的递归套路（中）</span></span></a></li><li><a class="level is-mobile" href="#13-二叉树常见面试题和二叉树的递归套路（下）、贪心算法"><span class="level-left"><span class="level-item">17</span><span class="level-item">13 二叉树常见面试题和二叉树的递归套路（下）、贪心算法</span></span></a></li><li><a class="level is-mobile" href="#14-贪心算法（续）、并查集"><span class="level-left"><span class="level-item">18</span><span class="level-item">14 贪心算法（续）、并查集</span></span></a></li><li><a class="level is-mobile" href="#15-并查集相关的常见面试题"><span class="level-left"><span class="level-item">19</span><span class="level-item">15 并查集相关的常见面试题</span></span></a></li><li><a class="level is-mobile" href="#16-图及其与图相关的算法"><span class="level-left"><span class="level-item">20</span><span class="level-item">16 图及其与图相关的算法</span></span></a></li><li><a class="level is-mobile" href="#17-用加强堆更好的实现-Dijkstra-算法、常见的递归"><span class="level-left"><span class="level-item">21</span><span class="level-item">17 用加强堆更好的实现 Dijkstra 算法、常见的递归</span></span></a></li><li><a class="level is-mobile" href="#18-暴力递归到动态规划（一）"><span class="level-left"><span class="level-item">22</span><span class="level-item">18 暴力递归到动态规划（一）</span></span></a></li><li><a class="level is-mobile" href="#19-暴力递归到动态规划（二）"><span class="level-left"><span class="level-item">23</span><span class="level-item">19 暴力递归到动态规划（二）</span></span></a></li><li><a class="level is-mobile" href="#20-暴力递归到动态规划（三）"><span class="level-left"><span class="level-item">24</span><span class="level-item">20 暴力递归到动态规划（三）</span></span></a></li><li><a class="level is-mobile" href="#21-暴力递归到动态规划（四）"><span class="level-left"><span class="level-item">25</span><span class="level-item">21 暴力递归到动态规划（四）</span></span></a></li><li><a class="level is-mobile" href="#22-暴力递归到动态规划（五）"><span class="level-left"><span class="level-item">26</span><span class="level-item">22 暴力递归到动态规划（五）</span></span></a></li><li><a class="level is-mobile" href="#23-暴力递归到动态规划（六）"><span class="level-left"><span class="level-item">27</span><span class="level-item">23 暴力递归到动态规划（六）</span></span></a></li><li><a class="level is-mobile" href="#24-窗口内最大值或最小值的更新结构"><span class="level-left"><span class="level-item">28</span><span class="level-item">24 窗口内最大值或最小值的更新结构</span></span></a></li><li><a class="level is-mobile" href="#25-单调栈"><span class="level-left"><span class="level-item">29</span><span class="level-item">25 单调栈</span></span></a></li><li><a class="level is-mobile" href="#26-单调栈相关的题目（续）、斐波那契数列的矩阵快速幂模型"><span class="level-left"><span class="level-item">30</span><span class="level-item">26 单调栈相关的题目（续）、斐波那契数列的矩阵快速幂模型</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-06T11:39:08.000Z">2023-03-06</time></p><p class="title"><a href="/2023/03/06/hello-world/">Hello World</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-06T11:39:08.000Z">2023-03-06</time></p><p class="title"><a href="/2023/03/06/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/">算法基础</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 AikenZh</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>